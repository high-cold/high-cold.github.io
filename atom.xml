<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>High-Cold</title>
  
  <subtitle>一个经常GG的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-28T11:32:01.286Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>high-cold</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>日语五十音入门练习</title>
    <link href="http://yoursite.com/2018/10/28/%E6%97%A5%E8%AF%AD%E4%BA%94%E5%8D%81%E9%9F%B3%E5%85%A5%E9%97%A8%E7%BB%83%E4%B9%A0/"/>
    <id>http://yoursite.com/2018/10/28/日语五十音入门练习/</id>
    <published>2018-10-28T11:17:54.000Z</published>
    <updated>2018-10-28T11:32:01.286Z</updated>
    
    <content type="html"><![CDATA[<p>(￣▽￣)~<em> 这是一个五十音的辨别测试程序（半成品），虽然界面有点丑，但是对于巩固对五十音的记忆还是颇有帮助的。</em>~(￣▽￣) 使用介绍（简略）:   按照一般行序输入开始字符与结束字符（先平假后片假，如あ是1，ア是2）   对一个得2分，错一个扣4分，无下限（其实你可以重开），100分过关。   <a href="https://github.com/high-cold/high-cold.github.io/tree/master/Downoad/%E6%97%A5%E8%AF%AD50%E9%9F%B3%E9%9A%8F%E6%9C%BA%E7%94%9F%E6%88%90%E5%99%A8.exe" target="_blank" rel="noopener">下载地址</a></p><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr><hr>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;(￣▽￣)~&lt;em&gt; 这是一个五十音的辨别测试程序（半成品），虽然界面有点丑，但是对于巩固对五十音的记忆还是颇有帮助的。&lt;/em&gt;~(￣▽￣)
 使用介绍（简略）:
   按照一般行序输入开始字符与结束字符（先平假后片假，如あ是1，ア是2）
   对一个得2分，错一个扣4分
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>基础分治练习题</title>
    <link href="http://yoursite.com/2018/10/18/%E5%9F%BA%E7%A1%80%E5%88%86%E6%B2%BB%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/18/基础分治练习题/</id>
    <published>2018-10-18T09:13:22.000Z</published>
    <updated>2018-10-19T13:02:14.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a><strong>1.1 题目描述</strong></h4><p>这是一道基础分治练习题。给你三个数列 {ai}, {bi}, {ci}，保证每个数列都恰好是一个排列。你需要求出满足 ai &lt; aj , bi &lt;bj , ci &lt; cj 的有序对 (i, j) 的数目。<a id="more"></a></p><h4 id="1-2-输入格式"><a href="#1-2-输入格式" class="headerlink" title="1.2 输入格式"></a><strong>1.2 输入格式</strong></h4><p>从文件 cdq.in 中读入数据。数据的第一行包含一个正整数 n，表示数列的长度。接下来一行三个非负整数 SA, SB, SC。为了避免过量的输入对程序的运行效率产生影响，{ai}, {bi}, {ci} 由以下代码生成：</p><pre><code><div class="highlight"><pre>const int N &#61; 2e6&#43;5&#59;&#10;unsigned int SA&#44;SB&#44;SC&#59;int n&#44;a&#91;N&#93;&#44;b&#91;N&#93;&#44;c&#91;N&#93;&#59;&#10;unsigned int rd&#40;&#41;&#10;&#123;&#10;    SA&#94;&#61;SA&#60;&#60;16&#59;SA&#94;&#61;SA&#62;&#62;5&#59;SA&#94;&#61;SA&#60;&#60;1&#59;&#10;    unsigned int t&#61;SA&#59;SA&#61;SB&#59;SB&#61;SC&#59;SC&#94;&#61;t&#94;SA&#59;return SC&#59;&#10;&#125;&#10;void gen&#40;int &#42;P&#41;&#10;&#123;&#10;    for &#40;int i&#61;1&#59;i&#60;&#61;n&#59;&#43;&#43;i&#41; P&#91;i&#93;&#61;i&#59;&#10;    for &#40;int i&#61;1&#59;i&#60;&#61;n&#59;&#43;&#43;i&#41; swap&#40;P&#91;i&#93;&#44;P&#91;1&#43;rd&#40;&#41;&#37;n&#93;&#41;&#59;&#10;&#125;&#10;int main&#40;&#41;&#10;&#123;&#10;    scanf&#40;&#34;&#37;d&#37;u&#37;u&#37;u&#34;&#44;&#38;n&#44;&#38;SA&#44;&#38;SB&#44;&#38;SC&#41;&#59;&#10;    gen&#40;a&#41;&#59;gen&#40;b&#41;&#59;gen&#40;c&#41;&#59;return 0&#59;&#10;&#125;</pre></div></code></pre><p>你可以在程序中自由运行这段代码。在下发文件中提供了这段代码的 cpp 文件，你可以选择直接在该 cpp 文件下编写程序，也可以假装看不见它。</p><h4 id="1-3-输出格式"><a href="#1-3-输出格式" class="headerlink" title="1.3 输出格式"></a><strong>1.3 输出格式</strong></h4><p>输出到文件 cdq.out 中。输出一行一个正整数 ans，表示满足条件的有序对 (i, j) 的对数。</p><h4 id="1-4-样例-1-输入"><a href="#1-4-样例-1-输入" class="headerlink" title="1.4 样例 1 输入"></a><strong>1.4 样例 1 输入</strong></h4><pre><code><div class="highlight"><pre>5&#10;233 666 667</pre></div></code></pre><h4 id="1-5-样例-1-输出"><a href="#1-5-样例-1-输出" class="headerlink" title="1.5 样例 1 输出"></a><strong>1.5 样例 1 输出</strong></h4><pre><code><div class="highlight"><pre>4</pre></div></code></pre><h4 id="1-6-样例-1-解释"><a href="#1-6-样例-1-解释" class="headerlink" title="1.6 样例 1 解释"></a><strong>1.6 样例 1 解释</strong></h4><p>生成的数列为 a = {1, 2, 3, 4, 5}, b = {1, 5, 3, 2, 4}, c = {3, 4, 2, 1, 5}。显然有且仅有 (1, 2),(1, 5),(3, 5),(4, 5) 这四个数对满足条件。</p><h4 id="1-7-样例-2-输入"><a href="#1-7-样例-2-输入" class="headerlink" title="1.7 样例 2 输入"></a><strong>1.7 样例 2 输入</strong></h4><pre><code><div class="highlight"><pre>100000&#10;123 456 789</pre></div></code></pre><h4 id="1-8-样例-2-输出"><a href="#1-8-样例-2-输出" class="headerlink" title="1.8 样例 2 输出"></a><strong>1.8 样例 2 输出</strong></h4><pre><code><div class="highlight"><pre>1258889897</pre></div></code></pre><h4 id="1-9-子任务"><a href="#1-9-子任务" class="headerlink" title="1.9 子任务"></a><strong>1.9 子任务</strong></h4><p>对于 100% 的数据，保证 1 ≤ n ≤ 2 × 106, 1 ≤ SA, SB, SC ≤ 109。请注意常数因子对程序运行效率带来的影响。<img src="https://s1.ax1x.com/2018/10/18/iwGS4U.jpg" alt="iwGS4U.jpg"></p><h4 id="1-10-提示"><a href="#1-10-提示" class="headerlink" title="1.10 提示"></a><strong>1.10 提示</strong></h4><p>加油！这是道水题！A 掉它</p><hr><hr><p>  看到这道题的第一眼就是cdq分治。敲开心。然后。。。</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJNe1.jpg" alt="iwJNe1.jpg"></p><p> <del>总之，只要你常数足够优秀（大概八分之一），就可以用cdqA掉此题</del>    然后我们来看看这道神仙题到底在干什么。    根据1.2给出的输入生成程序，我们能一眼看出生成的三个数列其实并木有重复的元素，而且都小于等于n。也就是说，，这三个数列其实都是1~n的排列。    然后我们看看数据范围：2e6，只有O(n)和O(nlogn)两种实际意义的复杂度可以过。那么，我们能想到什么呢？<strong>二维偏序</strong>是nlogn的。所以，我们可以尝试将题目转成求二维偏序。    我们来看下面这三个东西：</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJBWD.jpg" alt="iwJBWD.jpg"></p><p>   明显，对于符合要求的数对，一定会在X,Y,Z中各别计算一次，而对于不符合要求的，只会在X,Y,Z中的一个里被计算一次。那么，我们可以得出：</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJsQH.jpg" alt="iwJsQH.jpg"></p><p>   这样，这道题就解决了。（然而我并不知道为什么我一个log还没有两个log快。。。）</p><hr><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //STL¨ª¡§¨®???¡¤¡§</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //?¡§¨°?¨ºy?¡ìo¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; //?¡§¨°?¨º?¨¨?/¨º?3?o¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //¨ºy?Y¨¢¡Â¨º?¨¨?/¨º?3?</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; //¡Á?¡¤?¡ä?¡ä|¨¤¨ª</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //¡Á?¡¤?¡ä?¨¤¨¤</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; //?¡§¨°?1?¨®¨²¨º¡À??¦Ì?o¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1234567890</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b,c) for (register int i=a;i&lt;=b;i+=c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="comment">/*#include &lt;bitset&gt; //STL???¡¥¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;cstype&gt; //¡Á?¡¤?¡ä|¨¤¨ª</span></span><br><span class="line"><span class="comment">#include &lt;cerrno&gt; //?¡§¨°?¡ä¨ª?¨®??</span></span><br><span class="line"><span class="comment">#include &lt;complex&gt; //?¡ä¨ºy¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;clocale&gt; //?¡§¨°?¡À?¦Ì??¡¥o¡¥¨ºy</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt; //?¡§¨°??¨®??o¡¥¨ºy?¡ã?¨²¡ä?¡¤???o¡¥¨ºy</span></span><br><span class="line"><span class="comment">#include &lt;deque&gt; //STL?????¨®¨¢D¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;exception&gt; //¨°¨¬3¡ê¡ä|¨¤¨ª¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt; //???t¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;functional&gt; //STL?¡§¨°?????o¡¥¨ºy(¡ä¨²¨¬?????¡¤?)</span></span><br><span class="line"><span class="comment">#include &lt;limits&gt; //?¡§¨°??¡Â??¨ºy?Y¨¤¨¤D¨ª¡Á??¦Ì3¡ê¨¢?</span></span><br><span class="line"><span class="comment">#include &lt;list&gt; //STL??D?¨¢D¡À¨ª¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;map&gt; //STL¨®3¨¦?¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt; //2?¨ºy?¡¥¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;ios&gt; //?¨´¡À?¨º?¨¨?/¨º?3??¡ì3?</span></span><br><span class="line"><span class="comment">#include &lt;iosfwd&gt; //¨º?¨¨?/¨º?3??¦Ì¨ª3¨º1¨®?¦Ì??¡ã??¨¦¨´?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;istream&gt; //?¨´¡À?¨º?¨¨?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;ostream&gt; //?¨´¡À?¨º?3?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt; //STL?¨®¨¢D¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;set&gt; //STL?¡¥o?¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;sstream&gt; //?¨´¨®¨²¡Á?¡¤?¡ä?¦Ì?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt; //STL????¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;stdexcept&gt; //¡À¨º¡Á?¨°¨¬3¡ê¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;streambuf&gt; //¦Ì¡Á2?¨º?¨¨?/¨º?3??¡ì3?</span></span><br><span class="line"><span class="comment">#include &lt;utility&gt; //STL¨ª¡§¨®??¡ê¡ã?¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt; //STL?¡¥¨¬?¨ºy¡Á¨¦¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;cwchar.h&gt;//?¨ª¡Á?¡¤?¡ä|¨¤¨ª?¡ã¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;cwctype.h&gt; //?¨ª¡Á?¡¤?¡¤?¨¤¨¤*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">true<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">true<span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">true<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> buf[<span class="number">50</span>];</span><br><span class="line">true<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">truebuf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (x) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">true<span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[<span class="number">0</span>]=<span class="number">1</span>,buf[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (buf[<span class="number">0</span>]) <span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int find(int x)&#123;return fa[x]=fa[x]==x?x:find(fa[x]);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void add(int x,int y,int z)&#123;to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA,SB,SC;<span class="keyword">int</span> n,a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;SA^=SA&lt;&lt;<span class="number">16</span>;SA^=SA&gt;&gt;<span class="number">5</span>;SA^=SA&lt;&lt;<span class="number">1</span>;<span class="keyword">unsigned</span> <span class="keyword">int</span> t=SA;SA=SB;SB=SC;SC^=t^SA;<span class="keyword">return</span> SC;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen</span><span class="params">(<span class="keyword">int</span> *P)</span></span>&#123;rep(i,<span class="number">1</span>,n,<span class="number">1</span>)P[i]=i;rep(i,<span class="number">1</span>,n,<span class="number">1</span>)swap(P[i],P[<span class="number">1</span>+rd()%n]);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span><span class="keyword">int</span> a,b,c;&#125;p[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.a&lt;B.a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.b&lt;B.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpc</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.c&lt;B.c;&#125;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">2000005</span>],q[<span class="number">2000005</span>],l[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;++a[x],x+=lowbit(x));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> r=<span class="number">0</span>;<span class="keyword">for</span>(;x;r+=a[x],x-=lowbit(x));<span class="keyword">return</span> r;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%u%u%u"</span>,&amp;n,&amp;SA,&amp;SB,&amp;SC);</span><br><span class="line">    gen(a);gen(b);gen(c);</span><br><span class="line">    <span class="keyword">register</span> ll X=<span class="number">0</span>, Y=<span class="number">0</span>, Z=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n,<span class="number">1</span>)  p[i].a=a[i],p[i].b=b[i],p[i].c=c[i];</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpa);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)X+=get(t,p[i].b),upd(t,p[i].b);</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpb);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)Y+=get(q,p[i].c),upd(q,p[i].c);</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpc);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)Z+=get(l,p[i].a),upd(l,p[i].a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (X+Y+Z<span class="number">-1l</span>l*n*(n<span class="number">-1</span>)/<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>请自动忽视头文件里的乱码以及代码奇怪的高亮</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-题目描述&quot;&gt;&lt;a href=&quot;#1-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.1 题目描述&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这是一道基础分治练习题。
给你三个数列 {ai}, {bi}, {ci}，保证每个数列都恰好是一个排列。你需要求出满足 ai &amp;lt; aj , bi &amp;lt;
bj , ci &amp;lt; cj 的有序对 (i, j) 的数目。&lt;/p&gt;
    
    </summary>
    
      <category term="NOIP2018赛前集训试题解析" scheme="http://yoursite.com/categories/NOIP2018%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%AD%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LCA-LCT</title>
    <link href="http://yoursite.com/2018/05/16/LCA-LCT/"/>
    <id>http://yoursite.com/2018/05/16/LCA-LCT/</id>
    <published>2018-05-16T11:57:34.000Z</published>
    <updated>2018-10-19T09:52:53.434Z</updated>
    
    <content type="html"><![CDATA[<p>这是蒟蒻我现在会的唯一的动态树LCA</p><a id="more"></a><p>先access(u),splay(u),查看一下v所在splay的根是否为u，如果是的话，那么 LCA(u,v)=vLCA(u,v)=v ；</p><p>然后access(v),此时再splay(v),查询一下u所在splay中的根节点为是否为v，如果是的话那么 LCA(u,v)=uLCA(u,v)=u ;</p><p>否则的话splay(u), LCA(u,v)=fa[u]LCA(u,v)=fa[u] ;</p><p>这个结论是很显然的，如果 u,v 的LCA是他们中的某一个的话，那么假设 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.204ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 6546 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-4C" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/><path stroke-width="1" id="E1-MJMATHI-43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/><path stroke-width="1" id="E1-MJMATHI-41" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path stroke-width="1" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path stroke-width="1" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"> <use xlink:href="#E1-MJMATHI-4C" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-43" x="681" y="0"/> <use xlink:href="#E1-MJMATHI-41" x="1442" y="0"/> <use xlink:href="#E1-MJMAIN-28" x="2192" y="0"/> <use xlink:href="#E1-MJMATHI-75" x="2582" y="0"/><g transform="translate(3154,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text></g> <use xlink:href="#E1-MJMATHI-76" x="3764" y="0"/> <use xlink:href="#E1-MJMAIN-29" x="4249" y="0"/> <use xlink:href="#E1-MJMAIN-3D" x="4917" y="0"/> <use xlink:href="#E1-MJMATHI-75" x="5973" y="0"/></g></svg> ，那么u一定在v到根节点的路径上，在第二步时，access(v)以后u就与v在一棵子树中，所以 <svg xmlns:xlink="http://www.w3.org/1999/xlink" width="15.204ex" height="3.343ex" style="vertical-align: -1.171ex;" viewbox="0 -934.9 6546 1439.2" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-4C" d="M228 637Q194 637 192 641Q191 643 191 649Q191 673 202 682Q204 683 217 683Q271 680 344 680Q485 680 506 683H518Q524 677 524 674T522 656Q517 641 513 637H475Q406 636 394 628Q387 624 380 600T313 336Q297 271 279 198T252 88L243 52Q243 48 252 48T311 46H328Q360 46 379 47T428 54T478 72T522 106T564 161Q580 191 594 228T611 270Q616 273 628 273H641Q647 264 647 262T627 203T583 83T557 9Q555 4 553 3T537 0T494 -1Q483 -1 418 -1T294 0H116Q32 0 32 10Q32 17 34 24Q39 43 44 45Q48 46 59 46H65Q92 46 125 49Q139 52 144 61Q147 65 216 339T285 628Q285 635 228 637Z"/><path stroke-width="1" id="E1-MJMATHI-43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/><path stroke-width="1" id="E1-MJMATHI-41" d="M208 74Q208 50 254 46Q272 46 272 35Q272 34 270 22Q267 8 264 4T251 0Q249 0 239 0T205 1T141 2Q70 2 50 0H42Q35 7 35 11Q37 38 48 46H62Q132 49 164 96Q170 102 345 401T523 704Q530 716 547 716H555H572Q578 707 578 706L606 383Q634 60 636 57Q641 46 701 46Q726 46 726 36Q726 34 723 22Q720 7 718 4T704 0Q701 0 690 0T651 1T578 2Q484 2 455 0H443Q437 6 437 9T439 27Q443 40 445 43L449 46H469Q523 49 533 63L521 213H283L249 155Q208 86 208 74ZM516 260Q516 271 504 416T490 562L463 519Q447 492 400 412L310 260L413 259Q516 259 516 260Z"/><path stroke-width="1" id="E1-MJMAIN-28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"/><path stroke-width="1" id="E1-MJMATHI-75" d="M21 287Q21 295 30 318T55 370T99 420T158 442Q204 442 227 417T250 358Q250 340 216 246T182 105Q182 62 196 45T238 27T291 44T328 78L339 95Q341 99 377 247Q407 367 413 387T427 416Q444 431 463 431Q480 431 488 421T496 402L420 84Q419 79 419 68Q419 43 426 35T447 26Q469 29 482 57T512 145Q514 153 532 153Q551 153 551 144Q550 139 549 130T540 98T523 55T498 17T462 -8Q454 -10 438 -10Q372 -10 347 46Q345 45 336 36T318 21T296 6T267 -6T233 -11Q189 -11 155 7Q103 38 103 113Q103 170 138 262T173 379Q173 380 173 381Q173 390 173 393T169 400T158 404H154Q131 404 112 385T82 344T65 302T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-76" d="M173 380Q173 405 154 405Q130 405 104 376T61 287Q60 286 59 284T58 281T56 279T53 278T49 278T41 278H27Q21 284 21 287Q21 294 29 316T53 368T97 419T160 441Q202 441 225 417T249 361Q249 344 246 335Q246 329 231 291T200 202T182 113Q182 86 187 69Q200 26 250 26Q287 26 319 60T369 139T398 222T409 277Q409 300 401 317T383 343T365 361T357 383Q357 405 376 424T417 443Q436 443 451 425T467 367Q467 340 455 284T418 159T347 40T241 -11Q177 -11 139 22Q102 54 102 117Q102 148 110 181T151 298Q173 362 173 380Z"/><path stroke-width="1" id="E1-MJMAIN-29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"/><path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"> <use xlink:href="#E1-MJMATHI-4C" x="0" y="0"/> <use xlink:href="#E1-MJMATHI-43" x="681" y="0"/> <use xlink:href="#E1-MJMATHI-41" x="1442" y="0"/> <use xlink:href="#E1-MJMAIN-28" x="2192" y="0"/> <use xlink:href="#E1-MJMATHI-75" x="2582" y="0"/><g transform="translate(3154,0)"><text font-family="monospace" stroke="none" transform="scale(71.759) matrix(1 0 0 -1 0 0)">，</text></g> <use xlink:href="#E1-MJMATHI-76" x="3764" y="0"/> <use xlink:href="#E1-MJMAIN-29" x="4249" y="0"/> <use xlink:href="#E1-MJMAIN-3D" x="4917" y="0"/> <use xlink:href="#E1-MJMATHI-75" x="5973" y="0"/></g></svg> ，所以第二个步骤成立。第一步同理。 考虑第二种情况，如果 LCA(u,v)=tLCA(u,v)=t ，那么在前两步执行完后，u在splay的根的父节点一定在v所在的splay中，且splay(u)后, fa[u]==LCA(u,v)fa[u]==LCA(u,v) ;证毕。</p><p>贴上代码：</p><pre><code><div class="highlight"><pre>&#35;include &#60;algorithm&#62; &#47;&#47;STL&#36890;&#29992;&#31639;&#27861;&#10;&#35;include &#60;cmath&#62; &#47;&#47;&#23450;&#20041;&#25968;&#23398;&#20989;&#25968;&#10;&#35;include &#60;cstdio&#62; &#47;&#47;&#23450;&#20041;&#36755;&#20837;&#47;&#36755;&#20986;&#20989;&#25968;&#10;&#35;include &#60;iostream&#62; &#47;&#47;&#25968;&#25454;&#27969;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cstring&#62; &#47;&#47;&#23383;&#31526;&#20018;&#22788;&#29702;&#10;&#35;include &#60;string&#62; &#47;&#47;&#23383;&#31526;&#20018;&#31867;&#10;&#35;include &#60;ctime&#62; &#47;&#47;&#23450;&#20041;&#20851;&#20110;&#26102;&#38388;&#30340;&#20989;&#25968;&#10;&#35;define itn int&#10;&#35;define fro for&#10;&#35;define ll long long&#10;&#35;define reg register&#10;&#35;define inf 1234567890&#10;&#47;&#42;&#35;include &#60;bitset&#62; &#47;&#47;STL&#20301;&#38598;&#23481;&#22120;&#10;&#35;include &#60;cstype&#62; &#47;&#47;&#23383;&#31526;&#22788;&#29702;&#10;&#35;include &#60;cerrno&#62; &#47;&#47;&#23450;&#20041;&#38169;&#35823;&#30721;&#10;&#35;include &#60;complex&#62; &#47;&#47;&#22797;&#25968;&#31867;&#10;&#35;include &#60;clocale&#62; &#47;&#47;&#23450;&#20041;&#26412;&#22320;&#21270;&#20989;&#25968;&#10;&#35;include &#60;cstdlib&#62; &#47;&#47;&#23450;&#20041;&#26434;&#39033;&#20989;&#25968;&#21450;&#20869;&#23384;&#20998;&#37197;&#20989;&#25968;&#10;&#35;include &#60;deque&#62; &#47;&#47;STL&#21452;&#31471;&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;exception&#62; &#47;&#47;&#24322;&#24120;&#22788;&#29702;&#31867;&#10;&#35;include &#60;fstream&#62; &#47;&#47;&#25991;&#20214;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;functional&#62; &#47;&#47;STL&#23450;&#20041;&#36816;&#31639;&#20989;&#25968;&#40;&#20195;&#26367;&#36816;&#31639;&#31526;&#41;&#10;&#35;include &#60;limits&#62; &#47;&#47;&#23450;&#20041;&#21508;&#31181;&#25968;&#25454;&#31867;&#22411;&#26368;&#20540;&#24120;&#37327;&#10;&#35;include &#60;list&#62; &#47;&#47;STL&#32447;&#24615;&#21015;&#34920;&#23481;&#22120;&#10;&#35;include &#60;map&#62; &#47;&#47;STL&#26144;&#23556;&#23481;&#22120;&#10;&#35;include &#60;iomanip&#62; &#47;&#47;&#21442;&#25968;&#21270;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;ios&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;iosfwd&#62; &#47;&#47;&#36755;&#20837;&#47;&#36755;&#20986;&#31995;&#32479;&#20351;&#29992;&#30340;&#21069;&#32622;&#22768;&#26126;&#10;&#35;include &#60;istream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#27969;&#10;&#35;include &#60;ostream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20986;&#27969;&#10;&#35;include &#60;queue&#62; &#47;&#47;STL&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;set&#62; &#47;&#47;STL&#38598;&#21512;&#23481;&#22120;&#10;&#35;include &#60;sstream&#62; &#47;&#47;&#22522;&#20110;&#23383;&#31526;&#20018;&#30340;&#27969;&#10;&#35;include &#60;stack&#62; &#47;&#47;STL&#22534;&#26632;&#23481;&#22120;&#10;&#35;include &#60;stdexcept&#62; &#47;&#47;&#26631;&#20934;&#24322;&#24120;&#31867;&#10;&#35;include &#60;streambuf&#62; &#47;&#47;&#24213;&#23618;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;utility&#62; &#47;&#47;STL&#36890;&#29992;&#27169;&#26495;&#31867;&#10;&#35;include &#60;vector&#62; &#47;&#47;STL&#21160;&#24577;&#25968;&#32452;&#23481;&#22120;&#10;&#35;include &#60;cwchar&#46;h&#62;&#47;&#47;&#23485;&#23383;&#31526;&#22788;&#29702;&#21450;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cwctype&#46;h&#62; &#47;&#47;&#23485;&#23383;&#31526;&#20998;&#31867;&#42;&#47;&#10;&#10;using namespace std&#59;&#10;&#10;int ans&#59;&#10;&#10;int max&#40;int x&#44;int y&#41;&#123;return x&#62;y&#63;x&#58;y&#59;&#125;&#10;&#10;int min&#40;int x&#44;int y&#41;&#123;return x&#60;y&#63;x&#58;y&#59;&#125;&#10;&#10;int read&#40;&#41;&#10;&#123;&#10;    int x&#61;0&#44;f&#61;1&#59;char ch&#61;getchar&#40;&#41;&#59;&#10;    while &#40;ch&#60;&#39;0&#39; &#124;&#124; ch&#62;&#39;9&#39;&#41;&#123;if &#40;ch&#61;&#61;&#39;&#45;&#39;&#41;f&#61;&#45;1&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    while &#40;&#39;0&#39;&#60;&#61;ch &#38;&#38; ch&#60;&#61;&#39;9&#39;&#41;&#123;x&#61;x&#42;10&#43;&#40;ch&#94;48&#41;&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    return x&#42;f&#59;&#10;&#125;&#10;&#10;void write&#40;int x&#41;&#10;&#123;&#10;    int buf&#91;50&#93;&#59;&#10;    if &#40;x&#60;0&#41; putchar&#40;&#39;&#45;&#39;&#41;&#44;x&#61;&#45;x&#59;&#10;    buf&#91;0&#93;&#61;0&#59;&#10;    while &#40;x&#41; buf&#91;&#43;&#43;buf&#91;0&#93;&#93;&#61;x&#37;10&#44;x&#47;&#61;10&#59;&#10;    if &#40;&#33;buf&#91;0&#93;&#41; buf&#91;0&#93;&#61;1&#44;buf&#91;1&#93;&#61;0&#59;&#10;    while &#40;buf&#91;0&#93;&#41; putchar&#40;&#39;0&#39;&#43;buf&#91;buf&#91;0&#93;&#45;&#45;&#93;&#41;&#59;&#10;&#125;&#10;&#10;int fa&#91;500500&#93;&#44;ch&#91;500500&#93;&#91;3&#93;&#44;key&#91;500500&#93;&#44;sum&#91;500500&#93;&#44;lazy&#91;500500&#93;&#59;&#10;int stk&#91;500500&#93;&#44;top&#61;0&#59;&#10;&#10;int notroot&#40;int x&#41;&#123;return ch&#91;fa&#91;x&#93;&#93;&#91;0&#93;&#61;&#61;x&#124;&#124;ch&#91;fa&#91;x&#93;&#93;&#91;1&#93;&#61;&#61;x&#59;&#125;&#10;&#10;void pushr&#40;int x&#41;&#123;swap&#40;ch&#91;x&#93;&#91;0&#93;&#44;ch&#91;x&#93;&#91;1&#93;&#41;&#59;lazy&#91;x&#93;&#94;&#61;1&#59;&#125;&#10;&#10;void pushup&#40;int x&#41;&#123;sum&#91;x&#93;&#61;sum&#91;ch&#91;x&#93;&#91;0&#93;&#93;&#94;sum&#91;ch&#91;x&#93;&#91;1&#93;&#93;&#94;key&#91;x&#93;&#59;&#125;&#10;&#10;void pushdown&#40;int x&#41;&#10;&#123;&#10;    if &#40;lazy&#91;x&#93;&#41;&#10;    &#123;&#10;        if &#40;ch&#91;x&#93;&#91;0&#93;&#41; pushr&#40;ch&#91;x&#93;&#91;0&#93;&#41;&#59;&#10;        if &#40;ch&#91;x&#93;&#91;1&#93;&#41; pushr&#40;ch&#91;x&#93;&#91;1&#93;&#41;&#59;&#10;        lazy&#91;x&#93;&#61;0&#59;&#10;    &#125;&#10;&#125;&#10;&#10;void rot&#40;int x&#41;&#10;&#123;&#10;    int y&#61;fa&#91;x&#93;&#44;z&#61;fa&#91;y&#93;&#44;k&#61;ch&#91;y&#93;&#91;1&#93;&#61;&#61;x&#44;w&#61;ch&#91;x&#93;&#91;&#33;k&#93;&#59;&#10;    if &#40;notroot&#40;y&#41;&#41; ch&#91;z&#93;&#91;ch&#91;z&#93;&#91;1&#93;&#61;&#61;y&#93;&#61;x&#59;&#10;    ch&#91;x&#93;&#91;&#33;k&#93;&#61;y&#59;ch&#91;y&#93;&#91;k&#93;&#61;w&#59;&#10;    if &#40;w&#41; fa&#91;w&#93;&#61;y&#59;fa&#91;y&#93;&#61;x&#59;fa&#91;x&#93;&#61;z&#59;&#10;    pushup&#40;y&#41;&#59;&#10;&#125;&#10;&#10;void splay&#40;int x&#41;&#10;&#123;&#10;    int y&#61;x&#44;z&#59;top&#61;0&#59;&#10;    stk&#91;&#43;&#43;top&#93;&#61;y&#59;&#10;    while &#40;notroot&#40;y&#41;&#41; stk&#91;&#43;&#43;top&#93;&#61;y&#61;fa&#91;y&#93;&#59;&#10;    while &#40;top&#41; pushdown&#40;stk&#91;top&#45;&#45;&#93;&#41;&#59;&#10;    while &#40;notroot&#40;x&#41;&#41;&#10;    &#123;&#10;        y&#61;fa&#91;x&#93;&#44;z&#61;fa&#91;y&#93;&#59;&#10;        if &#40;notroot&#40;y&#41;&#41;&#10;            rot&#40;&#40;ch&#91;y&#93;&#91;0&#93;&#61;&#61;x&#41;&#94;&#40;ch&#91;z&#93;&#91;0&#93;&#61;&#61;y&#41;&#63;x&#58;y&#41;&#59;&#10;        rot&#40;x&#41;&#59;&#10;    &#125;&#10;    pushup&#40;x&#41;&#59;&#10;&#125;&#10;&#10;int access&#40;int root&#41;&#10;&#123;&#10;    int temp&#61;0&#59;&#10;    while &#40;root&#41;&#10;    &#123;&#10;        splay&#40;root&#41;&#59;&#10;        ch&#91;root&#93;&#91;1&#93;&#61;temp&#59;&#10;        temp&#61;root&#59;&#10;        root&#61;fa&#91;root&#93;&#59;&#10;    &#125;&#10;    return temp&#59;&#10;&#125;&#10;&#10;void makeroot&#40;int x&#41;&#123;access&#40;x&#41;&#59;splay&#40;x&#41;&#59;pushr&#40;x&#41;&#59;&#125;&#10;&#10;int findroot&#40;int x&#41;&#10;&#123;&#10;    access&#40;x&#41;&#59;splay&#40;x&#41;&#59;&#10;    while &#40;ch&#91;x&#93;&#91;0&#93;&#41; pushdown&#40;x&#41;&#44;x&#61;ch&#91;x&#93;&#91;0&#93;&#59;&#10;    return x&#59;&#10;&#125;&#10;&#10;void link&#40;int x&#44;int y&#41;&#123;makeroot&#40;x&#41;&#59;if &#40;findroot&#40;y&#41;&#33;&#61;x&#41; fa&#91;x&#93;&#61;y&#59;&#125;&#10;&#10;int lca&#40;int x&#44;int y&#41;&#10;&#123;&#10;    access&#40;x&#41;&#59;splay&#40;x&#41;&#59;&#10;    int u&#61;y&#59;&#10;    while &#40;notroot&#40;u&#41;&#41; u&#61;fa&#91;u&#93;&#59;&#10;    if &#40;u&#61;&#61;x&#41; return y&#59;&#10;    access&#40;y&#41;&#59;splay&#40;y&#41;&#59;&#10;    u&#61;x&#59;&#10;    while &#40;notroot&#40;u&#41;&#41; u&#61;fa&#91;u&#93;&#59;&#10;    if &#40;u&#61;&#61;y&#41; return x&#59;&#10;    splay&#40;x&#41;&#59;&#10;    return fa&#91;x&#93;&#59;&#10;&#125;&#10;&#10;int main&#40;&#41;&#10;&#123;&#10;    int n&#61;read&#40;&#41;&#44;m&#61;read&#40;&#41;&#44;s&#61;read&#40;&#41;&#59;&#10;    for &#40;int i&#61;1&#59;i&#60;n&#59;i&#43;&#43;&#41;&#10;    &#123;&#10;        int q&#61;read&#40;&#41;&#44;w&#61;read&#40;&#41;&#59;&#10;        makeroot&#40;s&#41;&#59;&#10;        link&#40;q&#44;w&#41;&#59;&#10;    &#125;&#10;    while &#40;m&#45;&#45;&#41;&#10;    &#123;&#10;        int q&#61;read&#40;&#41;&#44;w&#61;read&#40;&#41;&#59; &#10;        makeroot&#40;s&#41;&#59;&#10;        printf&#40;&#34;&#37;d&#92;n&#34;&#44;lca&#40;q&#44;w&#41;&#41;&#59;&#10;    &#125;&#10;    return 0&#59;&#10;&#125;</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是蒟蒻我现在会的唯一的动态树LCA&lt;/p&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>LCA-倍增</title>
    <link href="http://yoursite.com/2018/05/16/LCA-%E5%80%8D%E5%A2%9E/"/>
    <id>http://yoursite.com/2018/05/16/LCA-倍增/</id>
    <published>2018-05-16T11:57:17.000Z</published>
    <updated>2018-05-16T11:57:17.691Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LCA-树剖</title>
    <link href="http://yoursite.com/2018/05/16/LCA-%E6%A0%91%E5%89%96/"/>
    <id>http://yoursite.com/2018/05/16/LCA-树剖/</id>
    <published>2018-05-16T11:57:06.000Z</published>
    <updated>2018-10-19T09:50:27.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）"><a href="#树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）" class="headerlink" title="树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）"></a>树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）</h3><a id="more"></a><p>此题主要用到树剖的两个dfs所得的top,dfn(dep),size,fa,son数组。接着讲讲各个数组的含义。</p><p>第一次dfs：dfn(dep): 该点深度size: 已该点为根的子树包含的节点个数fa: 略son: 该点子节点中size最大的(即最重的子节点)</p><p>第二次dfs：<strong> top: 该点所在的链的顶端(深度最小的点) </strong></p><p>然后每次将深度大的点往上跳一条链，直到两个点在同一链上。</p><pre><code><div class="highlight"><pre>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){    return x&gt;y?x:y;}int min(int x,int y){    return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;'0' || ch&gt;'9'){if (ch=='-')f=-1;ch=getchar();}    while ('0'&lt;=ch &amp;&amp; ch&lt;='9'){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar('-'),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar('0'+buf[buf[0]--]);}struct p{    int to,v,next;}e[10001000];int cnt;int last[10001000],dfn[10001000],son[10001000],top[10001000],size[10001000],fa[10001000];void add(int a,int b,int v){    e[++cnt]=(p){b,v,last[a]},last[a]=cnt;} void dfs1(int x){    dfn[x]=dfn[fa[x]]+1;size[x]=1;    for(int i=last[x];i;i=e[i].next){        int to=e[i].to;        if(fa[x]!=to&amp;&amp;!fa[to]){            fa[to]=x;            dfs1(to);            size[x]+=size[to];            if(size[son[x]]&lt;size[to]) son[x]=to;        }    }}void dfs2(int x){    if(x==son[fa[x]])top[x]=top[fa[x]];    else top[x]=x;    for(int i=last[x];i;i=e[i].next)if(fa[e[i].to]==x) dfs2(e[i].to);}int main(){    int q,w;    int n=read(),m=read(),s=read();    for (int i=1;i&lt;=n-1;i++){        q=read();w=read();        add(q,w,0);add(w,q,0);    }    dfs1(s);    dfs2(s);    for (int i=1;i&lt;=m;i++){        int a=read(),b=read();        while (top[a]!=top[b]){            if (dfn[top[a]]&gt;dfn[top[b]]) a=fa[top[a]];            else b=fa[top[b]];        }        write(dfn[a]&lt;dfn[b]?a:b);        if (i!=m) putchar('\n');    }    return 0;}</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot;&gt;&lt;a href=&quot;#树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot; class=&quot;headerlink&quot; title=&quot;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot;&gt;&lt;/a&gt;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&lt;/h3&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>LCA-Tarjan</title>
    <link href="http://yoursite.com/2018/05/16/LCA-Tarjan/"/>
    <id>http://yoursite.com/2018/05/16/LCA-Tarjan/</id>
    <published>2018-05-16T11:56:52.000Z</published>
    <updated>2018-10-19T09:56:23.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。"><a href="#Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。" class="headerlink" title="Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。"></a>Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。</h3><a id="more"></a><p>其保证时间复杂度的方法是在遍历树的时候记录已经走过的分支口，使得回溯的时候可以O(1)得出两个点的LCA。但是在开始前必须先将要求的点对进行排序，不然算法会退化。</p><pre><code><div class="highlight"><pre>&#35;include &#60;algorithm&#62; &#47;&#47;STL&#36890;&#29992;&#31639;&#27861;&#10;&#35;include &#60;cmath&#62; &#47;&#47;&#23450;&#20041;&#25968;&#23398;&#20989;&#25968;&#10;&#35;include &#60;cstdio&#62; &#47;&#47;&#23450;&#20041;&#36755;&#20837;&#47;&#36755;&#20986;&#20989;&#25968;&#10;&#35;include &#60;iostream&#62; &#47;&#47;&#25968;&#25454;&#27969;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cstring&#62; &#47;&#47;&#23383;&#31526;&#20018;&#22788;&#29702;&#10;&#35;include &#60;string&#62; &#47;&#47;&#23383;&#31526;&#20018;&#31867;&#10;&#35;include &#60;ctime&#62; &#47;&#47;&#23450;&#20041;&#20851;&#20110;&#26102;&#38388;&#30340;&#20989;&#25968;&#10;&#35;define itn int&#10;&#35;define fro for&#10;&#35;define ll long long&#10;&#35;define reg register&#10;&#47;&#42;&#35;include &#60;bitset&#62; &#47;&#47;STL&#20301;&#38598;&#23481;&#22120;&#10;&#35;include &#60;cstype&#62; &#47;&#47;&#23383;&#31526;&#22788;&#29702;&#10;&#35;include &#60;cerrno&#62; &#47;&#47;&#23450;&#20041;&#38169;&#35823;&#30721;&#10;&#35;include &#60;complex&#62; &#47;&#47;&#22797;&#25968;&#31867;&#10;&#35;include &#60;clocale&#62; &#47;&#47;&#23450;&#20041;&#26412;&#22320;&#21270;&#20989;&#25968;&#10;&#35;include &#60;cstdlib&#62; &#47;&#47;&#23450;&#20041;&#26434;&#39033;&#20989;&#25968;&#21450;&#20869;&#23384;&#20998;&#37197;&#20989;&#25968;&#10;&#35;include &#60;deque&#62; &#47;&#47;STL&#21452;&#31471;&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;exception&#62; &#47;&#47;&#24322;&#24120;&#22788;&#29702;&#31867;&#10;&#35;include &#60;fstream&#62; &#47;&#47;&#25991;&#20214;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;functional&#62; &#47;&#47;STL&#23450;&#20041;&#36816;&#31639;&#20989;&#25968;&#40;&#20195;&#26367;&#36816;&#31639;&#31526;&#41;&#10;&#35;include &#60;limits&#62; &#47;&#47;&#23450;&#20041;&#21508;&#31181;&#25968;&#25454;&#31867;&#22411;&#26368;&#20540;&#24120;&#37327;&#10;&#35;include &#60;list&#62; &#47;&#47;STL&#32447;&#24615;&#21015;&#34920;&#23481;&#22120;&#10;&#35;include &#60;map&#62; &#47;&#47;STL&#26144;&#23556;&#23481;&#22120;&#10;&#35;include &#60;iomanip&#62; &#47;&#47;&#21442;&#25968;&#21270;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;ios&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;iosfwd&#62; &#47;&#47;&#36755;&#20837;&#47;&#36755;&#20986;&#31995;&#32479;&#20351;&#29992;&#30340;&#21069;&#32622;&#22768;&#26126;&#10;&#35;include &#60;istream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#27969;&#10;&#35;include &#60;ostream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20986;&#27969;&#10;&#35;include &#60;queue&#62; &#47;&#47;STL&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;set&#62; &#47;&#47;STL&#38598;&#21512;&#23481;&#22120;&#10;&#35;include &#60;sstream&#62; &#47;&#47;&#22522;&#20110;&#23383;&#31526;&#20018;&#30340;&#27969;&#10;&#35;include &#60;stack&#62; &#47;&#47;STL&#22534;&#26632;&#23481;&#22120;&#10;&#35;include &#60;stdexcept&#62; &#47;&#47;&#26631;&#20934;&#24322;&#24120;&#31867;&#10;&#35;include &#60;streambuf&#62; &#47;&#47;&#24213;&#23618;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;utility&#62; &#47;&#47;STL&#36890;&#29992;&#27169;&#26495;&#31867;&#10;&#35;include &#60;vector&#62; &#47;&#47;STL&#21160;&#24577;&#25968;&#32452;&#23481;&#22120;&#10;&#35;include &#60;cwchar&#46;h&#62;&#47;&#47;&#23485;&#23383;&#31526;&#22788;&#29702;&#21450;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cwctype&#46;h&#62; &#47;&#47;&#23485;&#23383;&#31526;&#20998;&#31867;&#42;&#47;&#10;&#10;using namespace std&#59;&#10;&#10;int max&#40;int x&#44;int y&#41;&#123;&#10;    return x&#62;y&#63;x&#58;y&#59;&#10;&#125;&#10;&#10;int min&#40;int x&#44;int y&#41;&#123;&#10;    return x&#60;y&#63;x&#58;y&#59;&#10;&#125;&#10;&#10;int read&#40;&#41;&#123;&#10;    int x&#61;0&#44;f&#61;1&#59;char ch&#61;getchar&#40;&#41;&#59;&#10;    while &#40;ch&#60;&#39;0&#39; &#124;&#124; ch&#62;&#39;9&#39;&#41;&#123;if &#40;ch&#61;&#61;&#39;&#45;&#39;&#41;f&#61;&#45;1&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    while &#40;&#39;0&#39;&#60;&#61;ch &#38;&#38; ch&#60;&#61;&#39;9&#39;&#41;&#123;x&#61;x&#42;10&#43;&#40;ch&#94;48&#41;&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    return x&#42;f&#59;&#10;&#125;&#10;&#10;void write&#40;int x&#41;&#123;&#10;    int buf&#91;50&#93;&#59;&#10;    if &#40;x&#60;0&#41; putchar&#40;&#39;&#45;&#39;&#41;&#44;x&#61;&#45;x&#59;&#10;    buf&#91;0&#93;&#61;0&#59;&#10;    while &#40;x&#41; buf&#91;&#43;&#43;buf&#91;0&#93;&#93;&#61;x&#37;10&#44;x&#47;&#61;10&#59;&#10;    if &#40;&#33;buf&#91;0&#93;&#41; buf&#91;0&#93;&#61;1&#44;buf&#91;1&#93;&#61;0&#59;&#10;    while &#40;buf&#91;0&#93;&#41; putchar&#40;&#39;0&#39;&#43;buf&#91;buf&#91;0&#93;&#45;&#45;&#93;&#41;&#59;&#10;&#125;&#10;&#10;int fir&#91;5005000&#93;&#44;to&#91;1001000&#93;&#44;ne&#91;1001000&#93;&#44;firp&#91;5005000&#93;&#44;as&#91;1001000&#93;&#44;nep&#91;1001000&#93;&#59;&#10;int ans&#91;1001000&#93;&#44;vis&#91;5005000&#93;&#44;f&#91;5001000&#93;&#44;fa&#91;5005000&#93;&#59; &#10;int n&#44;m&#44;s&#44;e&#44;q&#44;a&#44;b&#59;&#10;&#10;&#10;void add&#40;int u&#44;int v&#41;&#10;&#123;&#10;    to&#91;&#43;&#43;e&#93;&#61;v&#59;&#10;    ne&#91;e&#93;&#61;fir&#91;u&#93;&#59;&#10;    fir&#91;u&#93;&#61;e&#59;&#10;&#125;&#10;&#10;void app&#40;int x&#44;int y&#41;&#10;&#123;&#10;    as&#91;&#43;&#43;q&#93;&#61;y&#59;&#10;    nep&#91;q&#93;&#61;firp&#91;x&#93;&#59;&#10;    firp&#91;x&#93;&#61;q&#59;&#10;&#125;&#10;&#10;int find&#40;int x&#41;&#10;&#123;&#10;    if&#40;x&#33;&#61;fa&#91;x&#93;&#41; fa&#91;x&#93;&#61;find&#40;fa&#91;x&#93;&#41;&#59;&#10;    return fa&#91;x&#93;&#59;&#10;&#125;&#10;&#10;void un&#40;int x&#44;int y&#41;&#10;&#123;&#10;    int xx&#61;find&#40;x&#41;&#59;&#10;    int yy&#61;find&#40;y&#41;&#59;&#10;    if&#40;xx&#33;&#61;yy&#41; fa&#91;xx&#93;&#61;yy&#59;&#10;&#125;&#10;&#10;void tarjan&#40;int x&#41;&#10;&#123;&#10;    for&#40;int i&#61;fir&#91;x&#93;&#59;i&#59;i&#61;ne&#91;i&#93;&#41;&#10;    &#123;&#10;        int t&#61;to&#91;i&#93;&#59;&#10;        if&#40;t&#61;&#61;f&#91;x&#93;&#41; continue&#59; &#10;        f&#91;t&#93;&#61;x&#59;&#10;        tarjan&#40;t&#41;&#59;&#10;        un&#40;t&#44;x&#41;&#59;&#10;        vis&#91;t&#93;&#61;1&#59;&#10;    &#125;&#10;    for&#40;int i&#61;firp&#91;x&#93;&#59;i&#59;i&#61;nep&#91;i&#93;&#41;&#10;    &#123;&#10;        int y&#61;as&#91;i&#93;&#59;&#10;        if&#40;vis&#91;y&#93;&#41; ans&#91;i&#93;&#61;find&#40;y&#41;&#59;&#10;    &#125;&#10;&#125;&#10;&#10;&#10;int main&#40;&#41;&#10;&#123;&#10;    n&#61;read&#40;&#41;&#59;m&#61;read&#40;&#41;&#59;s&#61;read&#40;&#41;&#59;&#10;    for&#40;int i&#61;1&#59;i&#60;&#61;n&#45;1&#59;i&#43;&#43;&#41;&#10;        a&#61;read&#40;&#41;&#44;b&#61;read&#40;&#41;&#44;add&#40;a&#44;b&#41;&#44;add&#40;b&#44;a&#41;&#59;&#10;&#10;    for&#40;int i&#61;1&#59;i&#60;&#61;m&#59;i&#43;&#43;&#41;&#10;        a&#61;read&#40;&#41;&#44;b&#61;read&#40;&#41;&#44;app&#40;a&#44;b&#41;&#44;app&#40;b&#44;a&#41;&#59;&#10;&#10;    for&#40;int i&#61;1&#59;i&#60;&#61;n&#59;i&#43;&#43;&#41; fa&#91;i&#93;&#61;i&#44;f&#91;i&#93;&#61;i&#59;&#10;&#10;    tarjan&#40;s&#41;&#59;&#10;&#10;    for&#40;int i&#61;1&#59;i&#60;&#61;m&#59;i&#43;&#43;&#41;&#10;        printf&#40;&#34;&#37;d&#92;n&#34;&#44;max&#40;ans&#91;2&#42;i&#93;&#44;ans&#91;2&#42;i&#45;1&#93;&#41;&#41;&#59;&#10;&#10;    return 0&#59;&#10;&#125;</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。&quot;&gt;&lt;a href=&quot;#Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。&quot; class=&quot;headerlink&quot; title=&quot;Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。&quot;&gt;&lt;/a&gt;Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。&lt;/h3&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>左偏树（可并堆）</title>
    <link href="http://yoursite.com/2018/05/14/%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/14/左偏树（可并堆）/</id>
    <published>2018-05-14T11:03:35.000Z</published>
    <updated>2018-10-19T09:49:57.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左偏树-Leftist-Tree-是一种可并堆的实现。"><a href="#左偏树-Leftist-Tree-是一种可并堆的实现。" class="headerlink" title="左偏树(Leftist Tree)是一种可并堆的实现。"></a>左偏树(Leftist Tree)是一种可并堆的实现。</h1><p>左偏树相比于有两个额外的属性：键值和距离。<strong> 键值 </strong>是用于比较节点的大小。<strong> 距离 </strong>则是如下定义的：节点i称为外节点(external node)，当且仅当节点i的左子树或右子树为空(left(i)=NULL或right(i)=NULL)。节点i的距离(dist(i))是节点i到它的后代中，最近的外节点所经过的边数。特别的，如果节点i本身是外节点，则它的距离为0；而空节点的距离规定为-1 (dist(NULL)=-1)。</p><a id="more"></a><p>左偏树满足下面两条基本性质：</p><p>[性质1] 节点的键值小于或等于它的左右子节点的键值。即key(i)≤key(parent(i))</p><h5 id="性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i"><a href="#性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i" class="headerlink" title="[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))"></a>[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))</h5><p>这两条性质是对每一个节点而言的，因此可以简单地从中得出，左偏树的左右子树都是左偏树。由这两条性质，我们可以得出左偏树的定义：左偏树是具有左偏性质的堆有序二叉树。</p><p>下图是一棵左偏树：<img src="https://s1.ax1x.com/2018/05/16/CyMnNF.png" alt=""></p><p>[性质3] 节点的距离等于它的右子节点的距离加1。即dist(i)=dist(right(i))+1。</p><p>左偏树并不是为了快速访问所有的节点而设计的，它的目的是快速访问最小节点以及在对树修改后快速的恢复堆性质。从图中我们可以看到它并不平衡，由于性质2的缘故，它的结构偏向左侧，不过距离的概念和树的深度并不同，左偏树并不意味着<strong> 左子树的节点数或是深度一定大于右子树。 </strong></p><p>下面我们来讨论左偏树的距离和节点数的关系。</p><p><strong> [引理1] </strong> 若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树。证明：由性质2可知，当且仅当对于一棵左偏树中的每个节点i，都有dist(left(i))=dist(right(i))时，该左偏树的节点数最少。显然具有这样性质的二叉树是完全二叉树。</p><p><strong> [定理1] </strong> 若一棵左偏树的距离为k，则这棵左偏树至少有2^(k+1)-1个节点。证明：由引理1可知，当这样的左偏树节点数最少的时候，是一棵完全二叉树。距离为k的完全二叉树高度也为k，节点数为2^(k+1)-1，所以距离为k的左偏树至少有2k＋1-1个节点。</p><p>作为定理1的推论，我们有：</p><p>[性质4] 一棵N个节点的左偏树距离最多为O(log(N+1)-1)。</p><p>有了上面的4个性质，我们可以开始讨论左偏树的操作了。</p><h2 id="左偏树的合并"><a href="#左偏树的合并" class="headerlink" title="左偏树的合并"></a>左偏树的合并</h2><p>C ← Merge(A,B)把A,B两棵左偏树合并，返回一棵新的左偏树C，包含A和B中的所有元素。在本文中，一棵左偏树用它的根节点的指针表示。</p><p>在合并操作中，最简单的情况是其中一棵树为空（也就是，该树根节点指针为NULL）。这时我们只须要返回另一棵树。</p><p>若A和B都非空，我们假设A的根节点小于等于B的根节点（否则交换A,B），把A的根节点作为新树C的根节点，剩下的事就是合并A的右子树right(A)和B了。</p><p>right(A) ← Merge(right(A),B)</p><p>为了维护左偏性质，若dist(left(A))&gt;dist(right(A))，交换left(A)和right(A)。</p><p>最后，由于right(A) 的距离可能发生改变，我们必须更新A的距离：dist(A) ← dist(right(A)) + 1</p><p>于是合并就完成了。</p><p>下图是一个合并过程的示例：</p><p><img src="https://s1.ax1x.com/2018/05/16/CyMQ39.png" alt=""></p><h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><p>单节点的树一定是左偏树，因此向左偏树插入一个节点可以看作是对两棵左偏树的合并。</p><p>由于合并的其中一棵树只有一个节点，因此插入新节点操作的时间复杂度是O(logn)。</p><h2 id="删除最小节点"><a href="#删除最小节点" class="headerlink" title="删除最小节点"></a>删除最小节点</h2><p>由性质1，我们知道，左偏树的根节点是最小节点。在删除根节点后，剩下的两棵子树都是左偏树，需要把他们合并。</p><p>由于删除最小节点后只需进行一次合并，因此删除最小节点的时间复杂度也为O(logn)。</p><h2 id="左偏树的构建"><a href="#左偏树的构建" class="headerlink" title="左偏树的构建"></a>左偏树的构建</h2><p>将n个节点构建成一棵左偏树，这也是一个常用的操作。</p><p>算法一  暴力算法——逐个节点插入，时间复杂度为O(nlogn)。</p><p>算法二  仿照二叉堆的构建算法，我们可以得到下面这种算法：    将n个节点（每个节点作为一棵左偏树）放入先进先出队列。不断地从队首取出两棵左偏树，将它们合并之后加入队尾。当队列中只剩下一棵左偏树时，算法结束，时间复杂度为O(n)。</p><p><img src="https://s1.ax1x.com/2018/05/16/CyMcE8.png" alt=""></p><p>代码如下：</p><pre><code><div class="highlight"><pre>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register#define inf 1234567890/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){return x&gt;y?x:y;}int min(int x,int y){return x&lt;y?x:y;}void swap(int &amp;x,int &amp;y){int d=x;x=y;y=d;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;'0' || ch&gt;'9'){if (ch=='-')f=-1;ch=getchar();}    while ('0'&lt;=ch &amp;&amp; ch&lt;='9'){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar('-'),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;     if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar('0'+buf[buf[0]--]);}int fa[100100],dist[100100],Left[100100],Right[100100],key[100100];int find(int x){    return fa[x]?find(fa[x]):x;}int merge(int x,int y){    if (x==0) return y;    if (y==0) return x;    if (key[y]&lt;key[x]||(key[x]==key[y]&amp;&amp;x&gt;y)) swap(x,y);    int &amp;l=Left[x],&amp;r=Right[x];    r=merge(r,y);    fa[r]=x;    if (dist[r]&gt;dist[l]) swap(l,r);    dist[x]=dist[r]+1;}void Delete(int x){    key[x]=-1;    fa[Right[x]]=fa[Left[x]]=0;    merge(Left[x],Right[x]);}int main(){    int n=read(),m=read();    dist[0]=-1;    for (int i=1;i&lt;=n;i++) key[i]=read();    while (233333&amp;&amp;m--)    {        int q=read();        if (q==1)        {            int x=read(),y=read();            if (key[x]==-1||key[y]==-1) continue;            x=find(x),y=find(y);            if (x!=y) merge(x,y);        }        if (q==2)        {            int x=read();            if (key[x]==-1) printf("-1\n");            else             {                x=find(x);                printf("%d\n",key[x]);                Delete(x);            }        }    }    return 0;}</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;左偏树-Leftist-Tree-是一种可并堆的实现。&quot;&gt;&lt;a href=&quot;#左偏树-Leftist-Tree-是一种可并堆的实现。&quot; class=&quot;headerlink&quot; title=&quot;左偏树(Leftist Tree)是一种可并堆的实现。&quot;&gt;&lt;/a&gt;左偏树(Leftist Tree)是一种可并堆的实现。&lt;/h1&gt;&lt;p&gt;左偏树相比于有两个额外的属性：键值和距离。
&lt;strong&gt; 键值 &lt;/strong&gt;是用于比较节点的大小。
&lt;strong&gt; 距离 &lt;/strong&gt;则是如下定义的：
节点i称为外节点(external node)，当且仅当节点i的左子树或右子树为空(left(i)=NULL或right(i)=NULL)。
节点i的距离(dist(i))是节点i到它的后代中，最近的外节点所经过的边数。
特别的，如果节点i本身是外节点，则它的距离为0；而空节点的距离规定为-1 (dist(NULL)=-1)。&lt;/p&gt;
    
    </summary>
    
      <category term="左偏树" scheme="http://yoursite.com/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
    
      <category term="蒟蒻的板子" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84%E6%9D%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>卢卡斯定理</title>
    <link href="http://yoursite.com/2018/05/14/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/14/卢卡斯定理/</id>
    <published>2018-05-14T10:57:58.000Z</published>
    <updated>2018-10-19T09:50:07.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><a id="more"></a><p>这个定理，貌似只有组合数取模的时候可以用到，其他的没什么用(￣▽￣)~*</p><p>so，背公式吧</p><hr><p style="text-align: center; "><svg xmlns:xlink="http://www.w3.org/1999/xlink" width="38.473ex" height="4.176ex" style="vertical-align: -1.505ex;" viewbox="0 -1150.1 16564.6 1798" role="img" focusable="false" xmlns="http://www.w3.org/2000/svg"><defs><path stroke-width="1" id="E1-MJMATHI-43" d="M50 252Q50 367 117 473T286 641T490 704Q580 704 633 653Q642 643 648 636T656 626L657 623Q660 623 684 649Q691 655 699 663T715 679T725 690L740 705H746Q760 705 760 698Q760 694 728 561Q692 422 692 421Q690 416 687 415T669 413H653Q647 419 647 422Q647 423 648 429T650 449T651 481Q651 552 619 605T510 659Q484 659 454 652T382 628T299 572T226 479Q194 422 175 346T156 222Q156 108 232 58Q280 24 350 24Q441 24 512 92T606 240Q610 253 612 255T628 257Q648 257 648 248Q648 243 647 239Q618 132 523 55T319 -22Q206 -22 128 53T50 252Z"/><path stroke-width="1" id="E1-MJMATHI-6E" d="M21 287Q22 293 24 303T36 341T56 388T89 425T135 442Q171 442 195 424T225 390T231 369Q231 367 232 367L243 378Q304 442 382 442Q436 442 469 415T503 336T465 179T427 52Q427 26 444 26Q450 26 453 27Q482 32 505 65T540 145Q542 153 560 153Q580 153 580 145Q580 144 576 130Q568 101 554 73T508 17T439 -10Q392 -10 371 17T350 73Q350 92 386 193T423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 180T152 343Q153 348 153 366Q153 405 129 405Q91 405 66 305Q60 285 60 284Q58 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMATHI-6D" d="M21 287Q22 293 24 303T36 341T56 388T88 425T132 442T175 435T205 417T221 395T229 376L231 369Q231 367 232 367L243 378Q303 442 384 442Q401 442 415 440T441 433T460 423T475 411T485 398T493 385T497 373T500 364T502 357L510 367Q573 442 659 442Q713 442 746 415T780 336Q780 285 742 178T704 50Q705 36 709 31T724 26Q752 26 776 56T815 138Q818 149 821 151T837 153Q857 153 857 145Q857 144 853 130Q845 101 831 73T785 17T716 -10Q669 -10 648 17T627 73Q627 92 663 193T700 345Q700 404 656 404H651Q565 404 506 303L499 291L466 157Q433 26 428 16Q415 -11 385 -11Q372 -11 364 -4T353 8T350 18Q350 29 384 161L420 307Q423 322 423 345Q423 404 379 404H374Q288 404 229 303L222 291L189 157Q156 26 151 16Q138 -11 108 -11Q95 -11 87 -5T76 7T74 17Q74 30 112 181Q151 335 151 342Q154 357 154 369Q154 405 129 405Q107 405 92 377T69 316T57 280Q55 278 41 278H27Q21 284 21 287Z"/><path stroke-width="1" id="E1-MJMAIN-25" d="M465 605Q428 605 394 614T340 632T319 641Q332 608 332 548Q332 458 293 403T202 347Q145 347 101 402T56 548Q56 637 101 693T202 750Q241 750 272 719Q359 642 464 642Q580 642 650 732Q662 748 668 749Q670 750 673 750Q682 750 688 743T693 726Q178 -47 170 -52Q166 -56 160 -56Q147 -56 142 -45Q137 -36 142 -27Q143 -24 363 304Q469 462 525 546T581 630Q528 605 465 605ZM207 385Q235 385 263 427T292 548Q292 617 267 664T200 712Q193 712 186 709T167 698T147 668T134 615Q132 595 132 548V527Q132 436 165 403Q183 385 203 385H207ZM500 146Q500 234 544 290T647 347Q699 347 737 292T776 146T737 0T646 -56Q590 -56 545 0T500 146ZM651 -18Q679 -18 707 24T736 146Q736 215 711 262T644 309Q637 309 630 306T611 295T591 265T578 212Q577 200 577 146V124Q577 -18 647 -18H651Z"/><path stroke-width="1" id="E1-MJMATHI-70" d="M23 287Q24 290 25 295T30 317T40 348T55 381T75 411T101 433T134 442Q209 442 230 378L240 387Q302 442 358 442Q423 442 460 395T497 281Q497 173 421 82T249 -10Q227 -10 210 -4Q199 1 187 11T168 28L161 36Q160 35 139 -51T118 -138Q118 -144 126 -145T163 -148H188Q194 -155 194 -157T191 -175Q188 -187 185 -190T172 -194Q170 -194 161 -194T127 -193T65 -192Q-5 -192 -24 -194H-32Q-39 -187 -39 -183Q-37 -156 -26 -148H-6Q28 -147 33 -136Q36 -130 94 103T155 350Q156 355 156 364Q156 405 131 405Q109 405 94 377T71 316T59 280Q57 278 43 278H29Q23 284 23 287ZM178 102Q200 26 252 26Q282 26 310 49T356 107Q374 141 392 215T411 325V331Q411 405 350 405Q339 405 328 402T306 393T286 380T269 365T254 350T243 336T235 326L232 322Q232 321 229 308T218 264T204 212Q178 106 178 102Z"/><path stroke-width="1" id="E1-MJMAIN-3D" d="M56 347Q56 360 70 367H707Q722 359 722 347Q722 336 708 328L390 327H72Q56 332 56 347ZM56 153Q56 168 72 173H708Q722 163 722 153Q722 140 707 133H70Q56 140 56 153Z"/><path stroke-width="1" id="E1-MJMAIN-2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"/><path stroke-width="1" id="E1-MJMAIN-2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"/></defs><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="matrix(1 0 0 -1 0 0)"><g transform="translate(167,0)"><g transform="translate(-11,0)"><g transform="translate(0,-5)"> <use xlink:href="#E1-MJMATHI-43" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="1094" y="499"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="1011" y="-212"/> <use xlink:href="#E1-MJMAIN-25" x="1936" y="0"/> <use xlink:href="#E1-MJMATHI-70" x="3270" y="0"/> <use xlink:href="#E1-MJMAIN-3D" x="4051" y="0"/><g transform="translate(5107,0)"> <use xlink:href="#E1-MJMATHI-43" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="1011" y="-213"/></g> <use xlink:href="#E1-MJMAIN-2F" x="6544" y="0"/><g transform="translate(7044,0)"> <use xlink:href="#E1-MJMATHI-70" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="712" y="583"/></g> <use xlink:href="#E1-MJMAIN-2F" x="8073" y="0"/> <use xlink:href="#E1-MJMATHI-70" x="8573" y="0"/> <use xlink:href="#E1-MJMAIN-2217" x="9799" y="0"/><g transform="translate(11022,0)"> <use xlink:href="#E1-MJMATHI-43" x="0" y="0"/><g transform="translate(774,482)"> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6E" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-25" x="954" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-70" x="2141" y="0"/></g><g transform="translate(715,-367)"> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-6D" x="0" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMAIN-25" x="1232" y="0"/> <use transform="scale(0.707)" xlink:href="#E1-MJMATHI-70" x="2419" y="0"/></g></g> <use xlink:href="#E1-MJMAIN-25" x="14404" y="0"/> <use xlink:href="#E1-MJMATHI-70" x="15737" y="0"/></g></g></g></g></svg></p><hr><pre><code><div class="highlight"><pre>&#35;include &#60;algorithm&#62; &#47;&#47;STL&#36890;&#29992;&#31639;&#27861;&#10;&#35;include &#60;cmath&#62; &#47;&#47;&#23450;&#20041;&#25968;&#23398;&#20989;&#25968;&#10;&#35;include &#60;cstdio&#62; &#47;&#47;&#23450;&#20041;&#36755;&#20837;&#47;&#36755;&#20986;&#20989;&#25968;&#10;&#35;include &#60;iostream&#62; &#47;&#47;&#25968;&#25454;&#27969;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cstring&#62; &#47;&#47;&#23383;&#31526;&#20018;&#22788;&#29702;&#10;&#35;include &#60;string&#62; &#47;&#47;&#23383;&#31526;&#20018;&#31867;&#10;&#35;include &#60;ctime&#62; &#47;&#47;&#23450;&#20041;&#20851;&#20110;&#26102;&#38388;&#30340;&#20989;&#25968;&#10;&#35;define itn int&#10;&#35;define fro for&#10;&#35;define ll long long&#10;&#47;&#42;&#35;include &#60;bitset&#62; &#47;&#47;STL&#20301;&#38598;&#23481;&#22120;&#10;&#35;include &#60;cstype&#62; &#47;&#47;&#23383;&#31526;&#22788;&#29702;&#10;&#35;include &#60;cerrno&#62; &#47;&#47;&#23450;&#20041;&#38169;&#35823;&#30721;&#10;&#35;include &#60;complex&#62; &#47;&#47;&#22797;&#25968;&#31867;&#10;&#35;include &#60;clocale&#62; &#47;&#47;&#23450;&#20041;&#26412;&#22320;&#21270;&#20989;&#25968;&#10;&#35;include &#60;cstdlib&#62; &#47;&#47;&#23450;&#20041;&#26434;&#39033;&#20989;&#25968;&#21450;&#20869;&#23384;&#20998;&#37197;&#20989;&#25968;&#10;&#35;include &#60;deque&#62; &#47;&#47;STL&#21452;&#31471;&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;exception&#62; &#47;&#47;&#24322;&#24120;&#22788;&#29702;&#31867;&#10;&#35;include &#60;fstream&#62; &#47;&#47;&#25991;&#20214;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;functional&#62; &#47;&#47;STL&#23450;&#20041;&#36816;&#31639;&#20989;&#25968;&#40;&#20195;&#26367;&#36816;&#31639;&#31526;&#41;&#10;&#35;include &#60;limits&#62; &#47;&#47;&#23450;&#20041;&#21508;&#31181;&#25968;&#25454;&#31867;&#22411;&#26368;&#20540;&#24120;&#37327;&#10;&#35;include &#60;list&#62; &#47;&#47;STL&#32447;&#24615;&#21015;&#34920;&#23481;&#22120;&#10;&#35;include &#60;map&#62; &#47;&#47;STL&#26144;&#23556;&#23481;&#22120;&#10;&#35;include &#60;iomanip&#62; &#47;&#47;&#21442;&#25968;&#21270;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;ios&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;iosfwd&#62; &#47;&#47;&#36755;&#20837;&#47;&#36755;&#20986;&#31995;&#32479;&#20351;&#29992;&#30340;&#21069;&#32622;&#22768;&#26126;&#10;&#35;include &#60;istream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20837;&#27969;&#10;&#35;include &#60;ostream&#62; &#47;&#47;&#22522;&#26412;&#36755;&#20986;&#27969;&#10;&#35;include &#60;queue&#62; &#47;&#47;STL&#38431;&#21015;&#23481;&#22120;&#10;&#35;include &#60;set&#62; &#47;&#47;STL&#38598;&#21512;&#23481;&#22120;&#10;&#35;include &#60;sstream&#62; &#47;&#47;&#22522;&#20110;&#23383;&#31526;&#20018;&#30340;&#27969;&#10;&#35;include &#60;stack&#62; &#47;&#47;STL&#22534;&#26632;&#23481;&#22120;&#10;&#35;include &#60;stdexcept&#62; &#47;&#47;&#26631;&#20934;&#24322;&#24120;&#31867;&#10;&#35;include &#60;streambuf&#62; &#47;&#47;&#24213;&#23618;&#36755;&#20837;&#47;&#36755;&#20986;&#25903;&#25345;&#10;&#35;include &#60;utility&#62; &#47;&#47;STL&#36890;&#29992;&#27169;&#26495;&#31867;&#10;&#35;include &#60;vector&#62; &#47;&#47;STL&#21160;&#24577;&#25968;&#32452;&#23481;&#22120;&#10;&#35;include &#60;cwchar&#46;h&#62;&#47;&#47;&#23485;&#23383;&#31526;&#22788;&#29702;&#21450;&#36755;&#20837;&#47;&#36755;&#20986;&#10;&#35;include &#60;cwctype&#46;h&#62; &#47;&#47;&#23485;&#23383;&#31526;&#20998;&#31867;&#42;&#47;&#10;&#10;using namespace std&#59;&#10;&#10;int ans&#59;&#10;&#10;int max&#40;int x&#44;int y&#41;&#123;&#10;    return x&#62;y&#63;x&#58;y&#59;&#10;&#125;&#10;&#10;int min&#40;int x&#44;int y&#41;&#123;&#10;    return x&#60;y&#63;x&#58;y&#59;&#10;&#125;&#10;&#10;int read&#40;&#41;&#123;&#10;    int x&#61;0&#44;f&#61;1&#59;char ch&#61;getchar&#40;&#41;&#59;&#10;    while &#40;ch&#60;&#39;0&#39; &#124;&#124; ch&#62;&#39;9&#39;&#41;&#123;if &#40;ch&#61;&#61;&#39;&#45;&#39;&#41;f&#61;&#45;1&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    while &#40;&#39;0&#39;&#60;&#61;ch &#38;&#38; ch&#60;&#61;&#39;9&#39;&#41;&#123;x&#61;&#40;x&#60;&#60;3&#41;&#43;&#40;x&#60;&#60;1&#41;&#43;&#40;ch&#94;48&#41;&#59;ch&#61;getchar&#40;&#41;&#59;&#125;&#10;    return x&#42;f&#59;&#10;&#125;&#10;&#10;void write&#40;ll x&#41;&#123;&#10;    ll buf&#91;50&#93;&#59;&#10;    if &#40;x&#60;0&#41; putchar&#40;&#39;&#45;&#39;&#41;&#44;x&#61;&#45;x&#59;&#10;    buf&#91;0&#93;&#61;0&#59;&#10;    while &#40;x&#41; buf&#91;&#43;&#43;buf&#91;0&#93;&#93;&#61;x&#37;10&#44;x&#47;&#61;10&#59;&#10;    if &#40;&#33;buf&#91;0&#93;&#41; buf&#91;0&#93;&#61;1&#44;buf&#91;1&#93;&#61;0&#59;&#10;    while &#40;buf&#91;0&#93;&#41; putchar&#40;&#39;0&#39;&#43;buf&#91;buf&#91;0&#93;&#45;&#45;&#93;&#41;&#59;&#10;&#125;&#10;&#10;ll a&#91;101010&#93;&#44;b&#91;101010&#93;&#44;p&#59;&#10;&#10;ll cgm&#40;int x&#44;int y&#41;&#123;&#10;    if&#40;x&#60;y&#41; return 0&#59;&#10;    else if&#40;x&#60;p&#41; return b&#91;x&#93;&#42;a&#91;y&#93;&#42;a&#91;x&#45;y&#93;&#37;p&#59;&#10;    else return cgm&#40;x&#47;p&#44;y&#47;p&#41;&#42;cgm&#40;x&#37;p&#44;y&#37;p&#41;&#37;p&#59;&#10;&#125;&#10;&#10;int main&#40;&#41;&#123;&#10;    int t&#61;read&#40;&#41;&#59;&#10;    for &#40;int i&#61;1&#59;i&#60;&#61;t&#59;i&#43;&#43;&#41; &#123;&#10;        ll n&#61;read&#40;&#41;&#44;m&#61;read&#40;&#41;&#59;p&#61;read&#40;&#41;&#59;&#10;        a&#91;0&#93;&#61;a&#91;1&#93;&#61;b&#91;0&#93;&#61;b&#91;1&#93;&#61;1&#59;&#10;        for&#40;int i&#61;2&#59;i&#60;&#61;n&#43;m&#59;i&#43;&#43;&#41; b&#91;i&#93;&#61;b&#91;i&#45;1&#93;&#42;i&#37;p&#59;&#10;        for&#40;int i&#61;2&#59;i&#60;&#61;n&#43;m&#59;i&#43;&#43;&#41; a&#91;i&#93;&#61;&#40;p&#45;p&#47;i&#41;&#42;a&#91;p&#37;i&#93;&#37;p&#59;&#10;        for&#40;int i&#61;2&#59;i&#60;&#61;n&#43;m&#59;i&#43;&#43;&#41; a&#91;i&#93;&#61;a&#91;i&#45;1&#93;&#42;a&#91;i&#93;&#37;p&#59;&#10;        write&#40;cgm&#40;n&#43;m&#44;m&#41;&#41;&#44;putchar&#40;&#39;&#92;n&#39;&#41;&#59;&#10;    &#125;&#10;    return 0&#59;&#10;&#125;</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;卢卡斯定理&quot;&gt;&lt;a href=&quot;#卢卡斯定理&quot; class=&quot;headerlink&quot; title=&quot;卢卡斯定理&quot;&gt;&lt;/a&gt;卢卡斯定理&lt;/h2&gt;
    
    </summary>
    
      <category term="数论" scheme="http://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="蒟蒻的板子" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84%E6%9D%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Link Cut Tree （动态树）</title>
    <link href="http://yoursite.com/2018/05/14/Link-Cut-Tree-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/14/Link-Cut-Tree-（动态树）/</id>
    <published>2018-05-14T10:54:12.000Z</published>
    <updated>2018-10-19T09:50:17.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-LCT-Link-Cut-Tree"><a href="#关于-LCT-Link-Cut-Tree" class="headerlink" title="关于 LCT(Link-Cut-Tree)"></a>关于 LCT(Link-Cut-Tree)</h1><p>说难不难，总归是个板子；说简单也不简单，写法千变万化。总的来说就是把板子背熟，才能在考场上写的出来（但是貌似写的出来也看不出来 (～￣▽￣)～  ）</p><a id="more"></a><hr><p>下面说说各个函数的作用：</p><p>notroot：判断点x是不是其所在(实)链的顶点(根，亦或称在当前LCT中深度最小的点)</p><p>pushr：翻转操作(其实就是个推标记的)</p><p>pushup:将节点信息上传(一般是维护的信息)</p><p>pushdown：将节点信息下放(一般是标记)</p><p>rot、splay：。。。不要告诉我你不认识</p><p>access：打通点x到当前LCT的根的一条实链</p><p>makeroot：将x变为LCT的根</p><p>findroot：寻找原树的根</p><p>link：连接两个点</p><p>cut：切断一条连边</p><hr><pre><code><div class="highlight"><pre>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register#define inf 1234567890/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){return x&gt;y?x:y;}int min(int x,int y){return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;'0' || ch&gt;'9'){if (ch=='-')f=-1;ch=getchar();}    while ('0'&lt;=ch &amp;&amp; ch&lt;='9'){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar('-'),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar('0'+buf[buf[0]--]);}int fa[300300],ch[300300][3],key[300300],sum[300300],lazy[300300];int stk[300300],top=0;int notroot(int x){return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushr(int x){swap(ch[x][0],ch[x][1]);lazy[x]^=1;}void pushup(int x){sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^key[x];}void pushdown(int x){    if (lazy[x])    {        if (ch[x][0]) pushr(ch[x][0]);        if (ch[x][1]) pushr(ch[x][1]);        lazy[x]=0;    }}void rot(int x){    int y=fa[x],z=fa[y],k=ch[y][1]==x,w=ch[x][!k];    if (notroot(y)) ch[z][ch[z][1]==y]=x;    ch[x][!k]=y;ch[y][k]=w;    if (w) fa[w]=y;fa[y]=x;fa[x]=z;    pushup(y);}void splay(int x){    int y=x,z;top=0;    stk[++top]=y;    while (notroot(y)) stk[++top]=y=fa[y];    while (top) pushdown(stk[top--]);    while (notroot(x))    {        y=fa[x],z=fa[y];        if (notroot(y))            rot((ch[y][0]==x)^(ch[z][0]==y)?x:y);        rot(x);    }    pushup(x);}void access(int x){for (int y=0;x;x=fa[y=x]) splay(x),ch[x][1]=y,pushup(x);}void makeroot(int x){access(x);splay(x);pushr(x);}int findroot(int x){    access(x);splay(x);    while (ch[x][0]) pushdown(x),x=ch[x][0];    return x;}void split(int x,int y){makeroot(x);access(y);splay(y);}void link(int x,int y){makeroot(x);if (findroot(y)!=x) fa[x]=y;}void cut(int x,int y){    makeroot(x);    if (findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1])        fa[x]=ch[y][0]=0,pushup(y);}int main(){    int n=read(),m=read();    for (int i=1;i&lt;=n;i++) key[i]=read();    while (m--)    {        int q=read(),x=read(),y=read();        if (q==0) {split(x,y);printf("%d\n",sum[y]);}        if (q==1) link(x,y);        if (q==2) cut(x,y);        if (q==3) splay(x),key[x]=y;    }    return 0;}</pre></div></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-LCT-Link-Cut-Tree&quot;&gt;&lt;a href=&quot;#关于-LCT-Link-Cut-Tree&quot; class=&quot;headerlink&quot; title=&quot;关于 LCT(Link-Cut-Tree)&quot;&gt;&lt;/a&gt;关于 LCT(Link-Cut-Tree)&lt;/h1&gt;&lt;p&gt;说难不难，总归是个板子；说简单也不简单，写法千变万化。总的来说就是把板子背熟，才能在考场上写的出来（但是貌似写的出来也看不出来 (～￣▽￣)～  ）&lt;/p&gt;
    
    </summary>
    
      <category term="LCT" scheme="http://yoursite.com/categories/LCT/"/>
    
    
      <category term="蒟蒻的LCT" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCT/"/>
    
  </entry>
  
</feed>
