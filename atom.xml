<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>High-Cold</title>
  
  <subtitle>一个经常GG的人</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-10-19T13:02:14.999Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>high-cold</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基础分治练习题</title>
    <link href="http://yoursite.com/2018/10/18/%E5%9F%BA%E7%A1%80%E5%88%86%E6%B2%BB%E7%BB%83%E4%B9%A0%E9%A2%98/"/>
    <id>http://yoursite.com/2018/10/18/基础分治练习题/</id>
    <published>2018-10-18T09:13:22.000Z</published>
    <updated>2018-10-19T13:02:14.999Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-1-题目描述"><a href="#1-1-题目描述" class="headerlink" title="1.1 题目描述"></a><strong>1.1 题目描述</strong></h4><p>这是一道基础分治练习题。<br>给你三个数列 {ai}, {bi}, {ci}，保证每个数列都恰好是一个排列。你需要求出满足 ai &lt; aj , bi &lt;<br>bj , ci &lt; cj 的有序对 (i, j) 的数目。<br><a id="more"></a></p><h4 id="1-2-输入格式"><a href="#1-2-输入格式" class="headerlink" title="1.2 输入格式"></a><strong>1.2 输入格式</strong></h4><p>从文件 cdq.in 中读入数据。<br>数据的第一行包含一个正整数 n，表示数列的长度。接下来一行三个非负整数 SA, SB, SC。<br>为了避免过量的输入对程序的运行效率产生影响，{ai}, {bi}, {ci} 由以下代码生成：</p><pre><code>const int N = 2e6+5;unsigned int SA,SB,SC;int n,a[N],b[N],c[N];unsigned int rd(){    SA^=SA&lt;&lt;16;SA^=SA&gt;&gt;5;SA^=SA&lt;&lt;1;    unsigned int t=SA;SA=SB;SB=SC;SC^=t^SA;return SC;}void gen(int *P){    for (int i=1;i&lt;=n;++i) P[i]=i;    for (int i=1;i&lt;=n;++i) swap(P[i],P[1+rd()%n]);}int main(){    scanf(&quot;%d%u%u%u&quot;,&amp;n,&amp;SA,&amp;SB,&amp;SC);    gen(a);gen(b);gen(c);return 0;}</code></pre><p>你可以在程序中自由运行这段代码。在下发文件中提供了这段代码的 cpp 文件，你可以选择直接在<br>该 cpp 文件下编写程序，也可以假装看不见它。</p><h4 id="1-3-输出格式"><a href="#1-3-输出格式" class="headerlink" title="1.3 输出格式"></a><strong>1.3 输出格式</strong></h4><p>输出到文件 cdq.out 中。<br>输出一行一个正整数 ans，表示满足条件的有序对 (i, j) 的对数。</p><h4 id="1-4-样例-1-输入"><a href="#1-4-样例-1-输入" class="headerlink" title="1.4 样例 1 输入"></a><strong>1.4 样例 1 输入</strong></h4><pre><code>5233 666 667</code></pre><h4 id="1-5-样例-1-输出"><a href="#1-5-样例-1-输出" class="headerlink" title="1.5 样例 1 输出"></a><strong>1.5 样例 1 输出</strong></h4><pre><code>4</code></pre><h4 id="1-6-样例-1-解释"><a href="#1-6-样例-1-解释" class="headerlink" title="1.6 样例 1 解释"></a><strong>1.6 样例 1 解释</strong></h4><p>生成的数列为 a = {1, 2, 3, 4, 5}, b = {1, 5, 3, 2, 4}, c = {3, 4, 2, 1, 5}。<br>显然有且仅有 (1, 2),(1, 5),(3, 5),(4, 5) 这四个数对满足条件。</p><h4 id="1-7-样例-2-输入"><a href="#1-7-样例-2-输入" class="headerlink" title="1.7 样例 2 输入"></a><strong>1.7 样例 2 输入</strong></h4><pre><code>100000123 456 789</code></pre><h4 id="1-8-样例-2-输出"><a href="#1-8-样例-2-输出" class="headerlink" title="1.8 样例 2 输出"></a><strong>1.8 样例 2 输出</strong></h4><pre><code>1258889897</code></pre><h4 id="1-9-子任务"><a href="#1-9-子任务" class="headerlink" title="1.9 子任务"></a><strong>1.9 子任务</strong></h4><p>对于 100% 的数据，保证 1 ≤ n ≤ 2 × 106, 1 ≤ SA, SB, SC ≤ 109。<br>请注意常数因子对程序运行效率带来的影响。<br><img src="https://s1.ax1x.com/2018/10/18/iwGS4U.jpg" alt="iwGS4U.jpg"></p><h4 id="1-10-提示"><a href="#1-10-提示" class="headerlink" title="1.10 提示"></a><strong>1.10 提示</strong></h4><p>加油！这是道水题！A 掉它</p><hr><hr><p>  看到这道题的第一眼就是cdq分治。敲开心。然后。。。</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJNe1.jpg" alt="iwJNe1.jpg"></p><p> <del>总之，只要你常数足够优秀（大概八分之一），就可以用cdqA掉此题</del><br>    然后我们来看看这道神仙题到底在干什么。<br>    根据1.2给出的输入生成程序，我们能一眼看出生成的三个数列其实并木有重复的元素，而且都小于等于n。也就是说，，这三个数列其实都是1~n的排列。<br>    然后我们看看数据范围：2e6，只有O(n)和O(nlogn)两种实际意义的复杂度可以过。那么，我们能想到什么呢？<strong>二维偏序</strong>是nlogn的。所以，我们可以尝试将题目转成求二维偏序。<br>    我们来看下面这三个东西：</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJBWD.jpg" alt="iwJBWD.jpg"></p><p>   明显，对于符合要求的数对，一定会在X,Y,Z中各别计算一次，而对于不符合要求的，只会在X,Y,Z中的一个里被计算一次。那么，我们可以得出：</p><p>   <img src="https://s1.ax1x.com/2018/10/18/iwJsQH.jpg" alt="iwJsQH.jpg"></p><p>   这样，这道题就解决了。（然而我并不知道为什么我一个log还没有两个log快。。。）</p><hr><hr><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt; //STL¨ª¡§¨®???¡¤¡§</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt; //?¡§¨°?¨ºy?¡ìo¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt; //?¡§¨°?¨º?¨¨?/¨º?3?o¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt; //¨ºy?Y¨¢¡Â¨º?¨¨?/¨º?3?</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt; //¡Á?¡¤?¡ä?¡ä|¨¤¨ª</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt; //¡Á?¡¤?¡ä?¨¤¨¤</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt; //?¡§¨°?1?¨®¨²¨º¡À??¦Ì?o¡¥¨ºy</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> itn int</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> fro for</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> reg register</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> inf 1234567890</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> rep(i,a,b,c) for (register int i=a;i&lt;=b;i+=c)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> lowbit(x) (x&amp;-x)</span></span><br><span class="line"><span class="comment">/*#include &lt;bitset&gt; //STL???¡¥¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;cstype&gt; //¡Á?¡¤?¡ä|¨¤¨ª</span></span><br><span class="line"><span class="comment">#include &lt;cerrno&gt; //?¡§¨°?¡ä¨ª?¨®??</span></span><br><span class="line"><span class="comment">#include &lt;complex&gt; //?¡ä¨ºy¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;clocale&gt; //?¡§¨°?¡À?¦Ì??¡¥o¡¥¨ºy</span></span><br><span class="line"><span class="comment">#include &lt;cstdlib&gt; //?¡§¨°??¨®??o¡¥¨ºy?¡ã?¨²¡ä?¡¤???o¡¥¨ºy</span></span><br><span class="line"><span class="comment">#include &lt;deque&gt; //STL?????¨®¨¢D¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;exception&gt; //¨°¨¬3¡ê¡ä|¨¤¨ª¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;fstream&gt; //???t¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;functional&gt; //STL?¡§¨°?????o¡¥¨ºy(¡ä¨²¨¬?????¡¤?)</span></span><br><span class="line"><span class="comment">#include &lt;limits&gt; //?¡§¨°??¡Â??¨ºy?Y¨¤¨¤D¨ª¡Á??¦Ì3¡ê¨¢?</span></span><br><span class="line"><span class="comment">#include &lt;list&gt; //STL??D?¨¢D¡À¨ª¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;map&gt; //STL¨®3¨¦?¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;iomanip&gt; //2?¨ºy?¡¥¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;ios&gt; //?¨´¡À?¨º?¨¨?/¨º?3??¡ì3?</span></span><br><span class="line"><span class="comment">#include &lt;iosfwd&gt; //¨º?¨¨?/¨º?3??¦Ì¨ª3¨º1¨®?¦Ì??¡ã??¨¦¨´?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;istream&gt; //?¨´¡À?¨º?¨¨?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;ostream&gt; //?¨´¡À?¨º?3?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;queue&gt; //STL?¨®¨¢D¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;set&gt; //STL?¡¥o?¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;sstream&gt; //?¨´¨®¨²¡Á?¡¤?¡ä?¦Ì?¨¢¡Â</span></span><br><span class="line"><span class="comment">#include &lt;stack&gt; //STL????¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;stdexcept&gt; //¡À¨º¡Á?¨°¨¬3¡ê¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;streambuf&gt; //¦Ì¡Á2?¨º?¨¨?/¨º?3??¡ì3?</span></span><br><span class="line"><span class="comment">#include &lt;utility&gt; //STL¨ª¡§¨®??¡ê¡ã?¨¤¨¤</span></span><br><span class="line"><span class="comment">#include &lt;vector&gt; //STL?¡¥¨¬?¨ºy¡Á¨¦¨¨Y?¡Â</span></span><br><span class="line"><span class="comment">#include &lt;cwchar.h&gt;//?¨ª¡Á?¡¤?¡ä|¨¤¨ª?¡ã¨º?¨¨?/¨º?3?</span></span><br><span class="line"><span class="comment">#include &lt;cwctype.h&gt; //?¨ª¡Á?¡¤?¡¤?¨¤¨¤*/</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">read</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> x=<span class="number">0</span>,f=<span class="number">1</span>;<span class="keyword">char</span> ch=getchar();</span><br><span class="line">true<span class="keyword">while</span> (ch&lt;<span class="string">'0'</span> || ch&gt;<span class="string">'9'</span>)&#123;<span class="keyword">if</span> (ch==<span class="string">'-'</span>)f=<span class="number">-1</span>;ch=getchar();&#125;</span><br><span class="line">true<span class="keyword">while</span> (<span class="string">'0'</span>&lt;=ch &amp;&amp; ch&lt;=<span class="string">'9'</span>)&#123;x=x*<span class="number">10</span>+(ch^<span class="number">48</span>);ch=getchar();&#125;</span><br><span class="line">true<span class="keyword">return</span> x*f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">true<span class="keyword">int</span> buf[<span class="number">50</span>];</span><br><span class="line">true<span class="keyword">if</span> (x&lt;<span class="number">0</span>) <span class="built_in">putchar</span>(<span class="string">'-'</span>),x=-x;</span><br><span class="line">truebuf[<span class="number">0</span>]=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (x) buf[++buf[<span class="number">0</span>]]=x%<span class="number">10</span>,x/=<span class="number">10</span>;</span><br><span class="line">true<span class="keyword">if</span> (!buf[<span class="number">0</span>]) buf[<span class="number">0</span>]=<span class="number">1</span>,buf[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">true<span class="keyword">while</span> (buf[<span class="number">0</span>]) <span class="built_in">putchar</span>(<span class="string">'0'</span>+buf[buf[<span class="number">0</span>]--]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//int find(int x)&#123;return fa[x]=fa[x]==x?x:find(fa[x]);&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//void add(int x,int y,int z)&#123;to[++cnt]=y;v[cnt]=z;Next[cnt]=head[x];head[x]=cnt;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">2e6</span>+<span class="number">5</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> SA,SB,SC;<span class="keyword">int</span> n,a[N],b[N],c[N];</span><br><span class="line"><span class="function"><span class="keyword">unsigned</span> <span class="keyword">int</span> <span class="title">rd</span><span class="params">()</span></span>&#123;SA^=SA&lt;&lt;<span class="number">16</span>;SA^=SA&gt;&gt;<span class="number">5</span>;SA^=SA&lt;&lt;<span class="number">1</span>;<span class="keyword">unsigned</span> <span class="keyword">int</span> t=SA;SA=SB;SB=SC;SC^=t^SA;<span class="keyword">return</span> SC;&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gen</span><span class="params">(<span class="keyword">int</span> *P)</span></span>&#123;rep(i,<span class="number">1</span>,n,<span class="number">1</span>)P[i]=i;rep(i,<span class="number">1</span>,n,<span class="number">1</span>)swap(P[i],P[<span class="number">1</span>+rd()%n]);&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">P</span> &#123;</span><span class="keyword">int</span> a,b,c;&#125;p[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpa</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.a&lt;B.a;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpb</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.b&lt;B.b;&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">cmpc</span><span class="params">(<span class="keyword">const</span> P&amp;A,<span class="keyword">const</span> P&amp;B)</span></span>&#123;<span class="keyword">return</span> A.c&lt;B.c;&#125;</span><br><span class="line"><span class="keyword">int</span> t[<span class="number">2000005</span>],q[<span class="number">2000005</span>],l[<span class="number">2000005</span>];</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">upd</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">for</span>(;x&lt;=n;++a[x],x+=lowbit(x));&#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> *a,<span class="keyword">int</span> x)</span></span>&#123;<span class="keyword">int</span> r=<span class="number">0</span>;<span class="keyword">for</span>(;x;r+=a[x],x-=lowbit(x));<span class="keyword">return</span> r;&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%u%u%u"</span>,&amp;n,&amp;SA,&amp;SB,&amp;SC);</span><br><span class="line">    gen(a);gen(b);gen(c);</span><br><span class="line">    <span class="keyword">register</span> ll X=<span class="number">0</span>, Y=<span class="number">0</span>, Z=<span class="number">0</span>;</span><br><span class="line">    rep(i,<span class="number">1</span>,n,<span class="number">1</span>)  p[i].a=a[i],p[i].b=b[i],p[i].c=c[i];</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpa);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)X+=get(t,p[i].b),upd(t,p[i].b);</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpb);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)Y+=get(q,p[i].c),upd(q,p[i].c);</span><br><span class="line">    sort(p+<span class="number">1</span>, p+n+<span class="number">1</span>, cmpc);rep(i,<span class="number">1</span>,n,<span class="number">1</span>)Z+=get(l,p[i].a),upd(l,p[i].a);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%lld\n"</span>, (X+Y+Z<span class="number">-1l</span>l*n*(n<span class="number">-1</span>)/<span class="number">2</span>)/<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><del>请自动忽视头文件里的乱码以及代码奇怪的高亮</del></p>]]></content>
    
    <summary type="html">
    
      &lt;h4 id=&quot;1-1-题目描述&quot;&gt;&lt;a href=&quot;#1-1-题目描述&quot; class=&quot;headerlink&quot; title=&quot;1.1 题目描述&quot;&gt;&lt;/a&gt;&lt;strong&gt;1.1 题目描述&lt;/strong&gt;&lt;/h4&gt;&lt;p&gt;这是一道基础分治练习题。&lt;br&gt;给你三个数列 {ai}, {bi}, {ci}，保证每个数列都恰好是一个排列。你需要求出满足 ai &amp;lt; aj , bi &amp;lt;&lt;br&gt;bj , ci &amp;lt; cj 的有序对 (i, j) 的数目。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="NOIP2018赛前集训试题解析" scheme="http://yoursite.com/categories/NOIP2018%E8%B5%9B%E5%89%8D%E9%9B%86%E8%AE%AD%E8%AF%95%E9%A2%98%E8%A7%A3%E6%9E%90/"/>
    
    
      <category term="题解" scheme="http://yoursite.com/tags/%E9%A2%98%E8%A7%A3/"/>
    
  </entry>
  
  <entry>
    <title>LCA-LCT</title>
    <link href="http://yoursite.com/2018/05/16/LCA-LCT/"/>
    <id>http://yoursite.com/2018/05/16/LCA-LCT/</id>
    <published>2018-05-16T11:57:34.000Z</published>
    <updated>2018-10-19T09:52:53.434Z</updated>
    
    <content type="html"><![CDATA[<p>这是蒟蒻我现在会的唯一的动态树LCA</p><a id="more"></a><p>先access(u),splay(u),查看一下v所在splay的根是否为u，如果是的话，那么 LCA(u,v)=vLCA(u,v)=v ；</p><p>然后access(v),此时再splay(v),查询一下u所在splay中的根节点为是否为v，如果是的话那么 LCA(u,v)=uLCA(u,v)=u ;</p><p>否则的话splay(u), LCA(u,v)=fa[u]LCA(u,v)=fa[u] ;</p><p>这个结论是很显然的，如果 u,v 的LCA是他们中的某一个的话，那么假设 $LCA(u，v)=u$ ，那么u一定在v到根节点的路径上，在第二步时，access(v)以后u就与v在一棵子树中，所以 $LCA(u，v)=u$ ，所以第二个步骤成立。第一步同理。 考虑第二种情况，如果 LCA(u,v)=tLCA(u,v)=t ，那么在前两步执行完后，u在splay的根的父节点一定在v所在的splay中，且splay(u)后, fa[u]==LCA(u,v)fa[u]==LCA(u,v) ;证毕。</p><p>贴上代码：</p><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register#define inf 1234567890/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){return x&gt;y?x:y;}int min(int x,int y){return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}int fa[500500],ch[500500][3],key[500500],sum[500500],lazy[500500];int stk[500500],top=0;int notroot(int x){return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushr(int x){swap(ch[x][0],ch[x][1]);lazy[x]^=1;}void pushup(int x){sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^key[x];}void pushdown(int x){    if (lazy[x])    {        if (ch[x][0]) pushr(ch[x][0]);        if (ch[x][1]) pushr(ch[x][1]);        lazy[x]=0;    }}void rot(int x){    int y=fa[x],z=fa[y],k=ch[y][1]==x,w=ch[x][!k];    if (notroot(y)) ch[z][ch[z][1]==y]=x;    ch[x][!k]=y;ch[y][k]=w;    if (w) fa[w]=y;fa[y]=x;fa[x]=z;    pushup(y);}void splay(int x){    int y=x,z;top=0;    stk[++top]=y;    while (notroot(y)) stk[++top]=y=fa[y];    while (top) pushdown(stk[top--]);    while (notroot(x))    {        y=fa[x],z=fa[y];        if (notroot(y))            rot((ch[y][0]==x)^(ch[z][0]==y)?x:y);        rot(x);    }    pushup(x);}int access(int root){    int temp=0;    while (root)    {        splay(root);        ch[root][1]=temp;        temp=root;        root=fa[root];    }    return temp;}void makeroot(int x){access(x);splay(x);pushr(x);}int findroot(int x){    access(x);splay(x);    while (ch[x][0]) pushdown(x),x=ch[x][0];    return x;}void link(int x,int y){makeroot(x);if (findroot(y)!=x) fa[x]=y;}int lca(int x,int y){    access(x);splay(x);    int u=y;    while (notroot(u)) u=fa[u];    if (u==x) return y;    access(y);splay(y);    u=x;    while (notroot(u)) u=fa[u];    if (u==y) return x;    splay(x);    return fa[x];}int main(){    int n=read(),m=read(),s=read();    for (int i=1;i&lt;n;i++)    {        int q=read(),w=read();        makeroot(s);        link(q,w);    }    while (m--)    {        int q=read(),w=read();         makeroot(s);        printf(&quot;%d\n&quot;,lca(q,w));    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;这是蒟蒻我现在会的唯一的动态树LCA&lt;/p&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>LCA-倍增</title>
    <link href="http://yoursite.com/2018/05/16/LCA-%E5%80%8D%E5%A2%9E/"/>
    <id>http://yoursite.com/2018/05/16/LCA-倍增/</id>
    <published>2018-05-16T11:57:17.000Z</published>
    <updated>2018-05-16T11:57:17.691Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>LCA-树剖</title>
    <link href="http://yoursite.com/2018/05/16/LCA-%E6%A0%91%E5%89%96/"/>
    <id>http://yoursite.com/2018/05/16/LCA-树剖/</id>
    <published>2018-05-16T11:57:06.000Z</published>
    <updated>2018-10-19T09:50:27.600Z</updated>
    
    <content type="html"><![CDATA[<h3 id="树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）"><a href="#树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）" class="headerlink" title="树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）"></a>树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）</h3><a id="more"></a><p>此题主要用到树剖的两个dfs所得的top,dfn(dep),size,fa,son数组。接着讲讲各个数组的含义。</p><p>第一次dfs：<br>dfn(dep): 该点深度<br>size: 已该点为根的子树包含的节点个数<br>fa: 略<br>son: 该点子节点中size最大的(即最重的子节点)</p><p>第二次dfs：<br><strong> top: 该点所在的链的顶端(深度最小的点) </strong></p><p>然后每次将深度大的点往上跳一条链，直到两个点在同一链上。</p><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){    return x&gt;y?x:y;}int min(int x,int y){    return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}struct p{    int to,v,next;}e[10001000];int cnt;int last[10001000],dfn[10001000],son[10001000],top[10001000],size[10001000],fa[10001000];void add(int a,int b,int v){    e[++cnt]=(p){b,v,last[a]},last[a]=cnt;} void dfs1(int x){    dfn[x]=dfn[fa[x]]+1;size[x]=1;    for(int i=last[x];i;i=e[i].next){        int to=e[i].to;        if(fa[x]!=to&amp;&amp;!fa[to]){            fa[to]=x;            dfs1(to);            size[x]+=size[to];            if(size[son[x]]&lt;size[to]) son[x]=to;        }    }}void dfs2(int x){    if(x==son[fa[x]])top[x]=top[fa[x]];    else top[x]=x;    for(int i=last[x];i;i=e[i].next)if(fa[e[i].to]==x) dfs2(e[i].to);}int main(){    int q,w;    int n=read(),m=read(),s=read();    for (int i=1;i&lt;=n-1;i++){        q=read();w=read();        add(q,w,0);add(w,q,0);    }    dfs1(s);    dfs2(s);    for (int i=1;i&lt;=m;i++){        int a=read(),b=read();        while (top[a]!=top[b]){            if (dfn[top[a]]&gt;dfn[top[b]]) a=fa[top[a]];            else b=fa[top[b]];        }        write(dfn[a]&lt;dfn[b]?a:b);        if (i!=m) putchar(&#39;\n&#39;);    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot;&gt;&lt;a href=&quot;#树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot; class=&quot;headerlink&quot; title=&quot;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&quot;&gt;&lt;/a&gt;树剖，全称树链剖分，其中已重链剖分较为常用（还有实链剖分，但是与此题无关）&lt;/h3&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>LCA-Tarjan</title>
    <link href="http://yoursite.com/2018/05/16/LCA-Tarjan/"/>
    <id>http://yoursite.com/2018/05/16/LCA-Tarjan/</id>
    <published>2018-05-16T11:56:52.000Z</published>
    <updated>2018-10-19T09:56:23.093Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。"><a href="#Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。" class="headerlink" title="Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。"></a>Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。</h3><a id="more"></a><p>其保证时间复杂度的方法是在遍历树的时候记录已经走过的分支口，使得回溯的时候可以O(1)得出两个点的LCA。但是在开始前必须先将要求的点对进行排序，不然算法会退化。</p><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int max(int x,int y){    return x&gt;y?x:y;}int min(int x,int y){    return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}int fir[5005000],to[1001000],ne[1001000],firp[5005000],as[1001000],nep[1001000];int ans[1001000],vis[5005000],f[5001000],fa[5005000]; int n,m,s,e,q,a,b;void add(int u,int v){    to[++e]=v;    ne[e]=fir[u];    fir[u]=e;}void app(int x,int y){    as[++q]=y;    nep[q]=firp[x];    firp[x]=q;}int find(int x){    if(x!=fa[x]) fa[x]=find(fa[x]);    return fa[x];}void un(int x,int y){    int xx=find(x);    int yy=find(y);    if(xx!=yy) fa[xx]=yy;}void tarjan(int x){    for(int i=fir[x];i;i=ne[i])    {        int t=to[i];        if(t==f[x]) continue;         f[t]=x;        tarjan(t);        un(t,x);        vis[t]=1;    }    for(int i=firp[x];i;i=nep[i])    {        int y=as[i];        if(vis[y]) ans[i]=find(y);    }}int main(){    n=read();m=read();s=read();    for(int i=1;i&lt;=n-1;i++)        a=read(),b=read(),add(a,b),add(b,a);    for(int i=1;i&lt;=m;i++)        a=read(),b=read(),app(a,b),app(b,a);    for(int i=1;i&lt;=n;i++) fa[i]=i,f[i]=i;    tarjan(s);    for(int i=1;i&lt;=m;i++)        printf(&quot;%d\n&quot;,max(ans[2*i],ans[2*i-1]));    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。&quot;&gt;&lt;a href=&quot;#Tarjan-求LCA-是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为-O-n-m-（然而一般的并查集时间复杂度是O-nlogn-），小于树剖、倍增等方法。&quot; class=&quot;headerlink&quot; title=&quot;Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。&quot;&gt;&lt;/a&gt;Tarjan 求LCA 是一种十分优秀的离线算法（缺点就是必须离线），时间复杂度为 O(n+m)（然而一般的并查集时间复杂度是O(nlogn)），小于树剖、倍增等方法。&lt;/h3&gt;
    
    </summary>
    
      <category term="LCA" scheme="http://yoursite.com/categories/LCA/"/>
    
    
      <category term="蒟蒻的LCA" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCA/"/>
    
  </entry>
  
  <entry>
    <title>左偏树（可并堆）</title>
    <link href="http://yoursite.com/2018/05/14/%E5%B7%A6%E5%81%8F%E6%A0%91%EF%BC%88%E5%8F%AF%E5%B9%B6%E5%A0%86%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/14/左偏树（可并堆）/</id>
    <published>2018-05-14T11:03:35.000Z</published>
    <updated>2018-10-19T09:49:57.089Z</updated>
    
    <content type="html"><![CDATA[<h1 id="左偏树-Leftist-Tree-是一种可并堆的实现。"><a href="#左偏树-Leftist-Tree-是一种可并堆的实现。" class="headerlink" title="左偏树(Leftist Tree)是一种可并堆的实现。"></a>左偏树(Leftist Tree)是一种可并堆的实现。</h1><p>左偏树相比于有两个额外的属性：键值和距离。<br><strong> 键值 </strong>是用于比较节点的大小。<br><strong> 距离 </strong>则是如下定义的：<br>节点i称为外节点(external node)，当且仅当节点i的左子树或右子树为空(left(i)=NULL或right(i)=NULL)。<br>节点i的距离(dist(i))是节点i到它的后代中，最近的外节点所经过的边数。<br>特别的，如果节点i本身是外节点，则它的距离为0；而空节点的距离规定为-1 (dist(NULL)=-1)。</p><a id="more"></a><p>左偏树满足下面两条基本性质：</p><p>[性质1] 节点的键值小于或等于它的左右子节点的键值。即key(i)≤key(parent(i))</p><h5 id="性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i"><a href="#性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i" class="headerlink" title="[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))"></a>[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))</h5><p>这两条性质是对每一个节点而言的，因此可以简单地从中得出，左偏树的左右子树都是左偏树。<br>由这两条性质，我们可以得出左偏树的定义：左偏树是具有左偏性质的堆有序二叉树。</p><p>下图是一棵左偏树：<br><img src="https://s1.ax1x.com/2018/05/16/CyMnNF.png" alt=""></p><p>[性质3] 节点的距离等于它的右子节点的距离加1。即dist(i)=dist(right(i))+1。</p><p>左偏树并不是为了快速访问所有的节点而设计的，它的目的是快速访问最小节点以及在对树修改后快速的恢复堆性质。<br>从图中我们可以看到它并不平衡，由于性质2的缘故，它的结构偏向左侧，不过距离的概念和树的深度并不同，左偏树并不意味着<strong> 左子树的节点数或是深度一定大于右子树。 </strong></p><p>下面我们来讨论左偏树的距离和节点数的关系。</p><p><strong> [引理1] </strong> 若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树。<br>证明：由性质2可知，当且仅当对于一棵左偏树中的每个节点i，都有dist(left(i))=dist(right(i))时，该左偏树的节点数最少。显然具有这样性质的二叉树是完全二叉树。</p><p><strong> [定理1] </strong> 若一棵左偏树的距离为k，则这棵左偏树至少有2^(k+1)-1个节点。<br>证明：由引理1可知，当这样的左偏树节点数最少的时候，是一棵完全二叉树。距离为k的完全二叉树高度也为k，节点数为2^(k+1)-1，所以距离为k的左偏树至少有2k＋1-1个节点。</p><p>作为定理1的推论，我们有：</p><p>[性质4] 一棵N个节点的左偏树距离最多为O(log(N+1)-1)。</p><p>有了上面的4个性质，我们可以开始讨论左偏树的操作了。</p><h2 id="左偏树的合并"><a href="#左偏树的合并" class="headerlink" title="左偏树的合并"></a>左偏树的合并</h2><p>C ← Merge(A,B)<br>把A,B两棵左偏树合并，返回一棵新的左偏树C，包含A和B中的所有元素。在本文中，一棵左偏树用它的根节点的指针表示。</p><p>在合并操作中，最简单的情况是其中一棵树为空（也就是，该树根节点指针为NULL）。这时我们只须要返回另一棵树。</p><p>若A和B都非空，我们假设A的根节点小于等于B的根节点（否则交换A,B），把A的根节点作为新树C的根节点，剩下的事就是合并A的右子树right(A)和B了。</p><p>right(A) ← Merge(right(A),B)</p><p>为了维护左偏性质，若dist(left(A))&gt;dist(right(A))，交换left(A)和right(A)。</p><p>最后，由于right(A) 的距离可能发生改变，我们必须更新A的距离：<br>dist(A) ← dist(right(A)) + 1</p><p>于是合并就完成了。</p><p>下图是一个合并过程的示例：</p><p><img src="https://s1.ax1x.com/2018/05/16/CyMQ39.png" alt=""></p><h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><p>单节点的树一定是左偏树，因此向左偏树插入一个节点可以看作是对两棵左偏树的合并。</p><p>由于合并的其中一棵树只有一个节点，因此插入新节点操作的时间复杂度是O(logn)。</p><h2 id="删除最小节点"><a href="#删除最小节点" class="headerlink" title="删除最小节点"></a>删除最小节点</h2><p>由性质1，我们知道，左偏树的根节点是最小节点。在删除根节点后，剩下的两棵子树都是左偏树，需要把他们合并。</p><p>由于删除最小节点后只需进行一次合并，因此删除最小节点的时间复杂度也为O(logn)。</p><h2 id="左偏树的构建"><a href="#左偏树的构建" class="headerlink" title="左偏树的构建"></a>左偏树的构建</h2><p>将n个节点构建成一棵左偏树，这也是一个常用的操作。</p><p>算法一  暴力算法——逐个节点插入，时间复杂度为O(nlogn)。</p><p>算法二  仿照二叉堆的构建算法，我们可以得到下面这种算法：<br>    将n个节点（每个节点作为一棵左偏树）放入先进先出队列。不断地从队首取出两棵左偏树，将它们合并之后加入队尾。当队列中只剩下一棵左偏树时，算法结束，时间复杂度为O(n)。</p><p><img src="https://s1.ax1x.com/2018/05/16/CyMcE8.png" alt=""></p><p>代码如下：</p><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register#define inf 1234567890/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){return x&gt;y?x:y;}int min(int x,int y){return x&lt;y?x:y;}void swap(int &amp;x,int &amp;y){int d=x;x=y;y=d;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;     if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}int fa[100100],dist[100100],Left[100100],Right[100100],key[100100];int find(int x){    return fa[x]?find(fa[x]):x;}int merge(int x,int y){    if (x==0) return y;    if (y==0) return x;    if (key[y]&lt;key[x]||(key[x]==key[y]&amp;&amp;x&gt;y)) swap(x,y);    int &amp;l=Left[x],&amp;r=Right[x];    r=merge(r,y);    fa[r]=x;    if (dist[r]&gt;dist[l]) swap(l,r);    dist[x]=dist[r]+1;}void Delete(int x){    key[x]=-1;    fa[Right[x]]=fa[Left[x]]=0;    merge(Left[x],Right[x]);}int main(){    int n=read(),m=read();    dist[0]=-1;    for (int i=1;i&lt;=n;i++) key[i]=read();    while (233333&amp;&amp;m--)    {        int q=read();        if (q==1)        {            int x=read(),y=read();            if (key[x]==-1||key[y]==-1) continue;            x=find(x),y=find(y);            if (x!=y) merge(x,y);        }        if (q==2)        {            int x=read();            if (key[x]==-1) printf(&quot;-1\n&quot;);            else             {                x=find(x);                printf(&quot;%d\n&quot;,key[x]);                Delete(x);            }        }    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;左偏树-Leftist-Tree-是一种可并堆的实现。&quot;&gt;&lt;a href=&quot;#左偏树-Leftist-Tree-是一种可并堆的实现。&quot; class=&quot;headerlink&quot; title=&quot;左偏树(Leftist Tree)是一种可并堆的实现。&quot;&gt;&lt;/a&gt;左偏树(Leftist Tree)是一种可并堆的实现。&lt;/h1&gt;&lt;p&gt;左偏树相比于有两个额外的属性：键值和距离。&lt;br&gt;&lt;strong&gt; 键值 &lt;/strong&gt;是用于比较节点的大小。&lt;br&gt;&lt;strong&gt; 距离 &lt;/strong&gt;则是如下定义的：&lt;br&gt;节点i称为外节点(external node)，当且仅当节点i的左子树或右子树为空(left(i)=NULL或right(i)=NULL)。&lt;br&gt;节点i的距离(dist(i))是节点i到它的后代中，最近的外节点所经过的边数。&lt;br&gt;特别的，如果节点i本身是外节点，则它的距离为0；而空节点的距离规定为-1 (dist(NULL)=-1)。&lt;/p&gt;
    
    </summary>
    
      <category term="左偏树" scheme="http://yoursite.com/categories/%E5%B7%A6%E5%81%8F%E6%A0%91/"/>
    
    
      <category term="蒟蒻的板子" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84%E6%9D%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>卢卡斯定理</title>
    <link href="http://yoursite.com/2018/05/14/%E5%8D%A2%E5%8D%A1%E6%96%AF%E5%AE%9A%E7%90%86/"/>
    <id>http://yoursite.com/2018/05/14/卢卡斯定理/</id>
    <published>2018-05-14T10:57:58.000Z</published>
    <updated>2018-10-19T09:50:07.755Z</updated>
    
    <content type="html"><![CDATA[<h2 id="卢卡斯定理"><a href="#卢卡斯定理" class="headerlink" title="卢卡斯定理"></a>卢卡斯定理</h2><a id="more"></a><p>这个定理，貌似只有组合数取模的时候可以用到，其他的没什么用(￣▽￣)~*</p><p>so，背公式吧</p><hr><script type="math/tex; mode=display">\begin{eqnarray}C_m^n~~\%~~p=C_m/p^n/p~~*~~C_{m~\%~p}^{n~\%~p}~~\%~~p \end{eqnarray}</script><hr><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){    return x&gt;y?x:y;}int min(int x,int y){    return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=(x&lt;&lt;3)+(x&lt;&lt;1)+(ch^48);ch=getchar();}    return x*f;}void write(ll x){    ll buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}ll a[101010],b[101010],p;ll cgm(int x,int y){    if(x&lt;y) return 0;    else if(x&lt;p) return b[x]*a[y]*a[x-y]%p;    else return cgm(x/p,y/p)*cgm(x%p,y%p)%p;}int main(){    int t=read();    for (int i=1;i&lt;=t;i++) {        ll n=read(),m=read();p=read();        a[0]=a[1]=b[0]=b[1]=1;        for(int i=2;i&lt;=n+m;i++) b[i]=b[i-1]*i%p;        for(int i=2;i&lt;=n+m;i++) a[i]=(p-p/i)*a[p%i]%p;        for(int i=2;i&lt;=n+m;i++) a[i]=a[i-1]*a[i]%p;        write(cgm(n+m,m)),putchar(&#39;\n&#39;);    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;卢卡斯定理&quot;&gt;&lt;a href=&quot;#卢卡斯定理&quot; class=&quot;headerlink&quot; title=&quot;卢卡斯定理&quot;&gt;&lt;/a&gt;卢卡斯定理&lt;/h2&gt;
    
    </summary>
    
      <category term="数论" scheme="http://yoursite.com/categories/%E6%95%B0%E8%AE%BA/"/>
    
    
      <category term="蒟蒻的板子" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84%E6%9D%BF%E5%AD%90/"/>
    
  </entry>
  
  <entry>
    <title>Link Cut Tree （动态树）</title>
    <link href="http://yoursite.com/2018/05/14/Link-Cut-Tree-%EF%BC%88%E5%8A%A8%E6%80%81%E6%A0%91%EF%BC%89/"/>
    <id>http://yoursite.com/2018/05/14/Link-Cut-Tree-（动态树）/</id>
    <published>2018-05-14T10:54:12.000Z</published>
    <updated>2018-10-19T09:50:17.400Z</updated>
    
    <content type="html"><![CDATA[<h1 id="关于-LCT-Link-Cut-Tree"><a href="#关于-LCT-Link-Cut-Tree" class="headerlink" title="关于 LCT(Link-Cut-Tree)"></a>关于 LCT(Link-Cut-Tree)</h1><p>说难不难，总归是个板子；说简单也不简单，写法千变万化。总的来说就是把板子背熟，才能在考场上写的出来（但是貌似写的出来也看不出来 (～￣▽￣)～  ）</p><a id="more"></a><hr><p>下面说说各个函数的作用：</p><p>notroot：判断点x是不是其所在(实)链的顶点(根，亦或称在当前LCT中深度最小的点)</p><p>pushr：翻转操作(其实就是个推标记的)</p><p>pushup:将节点信息上传(一般是维护的信息)</p><p>pushdown：将节点信息下放(一般是标记)</p><p>rot、splay：。。。不要告诉我你不认识</p><p>access：打通点x到当前LCT的根的一条实链</p><p>makeroot：将x变为LCT的根</p><p>findroot：寻找原树的根</p><p>link：连接两个点</p><p>cut：切断一条连边</p><hr><pre><code>#include &lt;algorithm&gt; //STL通用算法#include &lt;cmath&gt; //定义数学函数#include &lt;cstdio&gt; //定义输入/输出函数#include &lt;iostream&gt; //数据流输入/输出#include &lt;cstring&gt; //字符串处理#include &lt;string&gt; //字符串类#include &lt;ctime&gt; //定义关于时间的函数#define itn int#define fro for#define ll long long#define reg register#define inf 1234567890/*#include &lt;bitset&gt; //STL位集容器#include &lt;cstype&gt; //字符处理#include &lt;cerrno&gt; //定义错误码#include &lt;complex&gt; //复数类#include &lt;clocale&gt; //定义本地化函数#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数#include &lt;deque&gt; //STL双端队列容器#include &lt;exception&gt; //异常处理类#include &lt;fstream&gt; //文件输入/输出#include &lt;functional&gt; //STL定义运算函数(代替运算符)#include &lt;limits&gt; //定义各种数据类型最值常量#include &lt;list&gt; //STL线性列表容器#include &lt;map&gt; //STL映射容器#include &lt;iomanip&gt; //参数化输入/输出#include &lt;ios&gt; //基本输入/输出支持#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明#include &lt;istream&gt; //基本输入流#include &lt;ostream&gt; //基本输出流#include &lt;queue&gt; //STL队列容器#include &lt;set&gt; //STL集合容器#include &lt;sstream&gt; //基于字符串的流#include &lt;stack&gt; //STL堆栈容器#include &lt;stdexcept&gt; //标准异常类#include &lt;streambuf&gt; //底层输入/输出支持#include &lt;utility&gt; //STL通用模板类#include &lt;vector&gt; //STL动态数组容器#include &lt;cwchar.h&gt;//宽字符处理及输入/输出#include &lt;cwctype.h&gt; //宽字符分类*/using namespace std;int ans;int max(int x,int y){return x&gt;y?x:y;}int min(int x,int y){return x&lt;y?x:y;}int read(){    int x=0,f=1;char ch=getchar();    while (ch&lt;&#39;0&#39; || ch&gt;&#39;9&#39;){if (ch==&#39;-&#39;)f=-1;ch=getchar();}    while (&#39;0&#39;&lt;=ch &amp;&amp; ch&lt;=&#39;9&#39;){x=x*10+(ch^48);ch=getchar();}    return x*f;}void write(int x){    int buf[50];    if (x&lt;0) putchar(&#39;-&#39;),x=-x;    buf[0]=0;    while (x) buf[++buf[0]]=x%10,x/=10;    if (!buf[0]) buf[0]=1,buf[1]=0;    while (buf[0]) putchar(&#39;0&#39;+buf[buf[0]--]);}int fa[300300],ch[300300][3],key[300300],sum[300300],lazy[300300];int stk[300300],top=0;int notroot(int x){return ch[fa[x]][0]==x||ch[fa[x]][1]==x;}void pushr(int x){swap(ch[x][0],ch[x][1]);lazy[x]^=1;}void pushup(int x){sum[x]=sum[ch[x][0]]^sum[ch[x][1]]^key[x];}void pushdown(int x){    if (lazy[x])    {        if (ch[x][0]) pushr(ch[x][0]);        if (ch[x][1]) pushr(ch[x][1]);        lazy[x]=0;    }}void rot(int x){    int y=fa[x],z=fa[y],k=ch[y][1]==x,w=ch[x][!k];    if (notroot(y)) ch[z][ch[z][1]==y]=x;    ch[x][!k]=y;ch[y][k]=w;    if (w) fa[w]=y;fa[y]=x;fa[x]=z;    pushup(y);}void splay(int x){    int y=x,z;top=0;    stk[++top]=y;    while (notroot(y)) stk[++top]=y=fa[y];    while (top) pushdown(stk[top--]);    while (notroot(x))    {        y=fa[x],z=fa[y];        if (notroot(y))            rot((ch[y][0]==x)^(ch[z][0]==y)?x:y);        rot(x);    }    pushup(x);}void access(int x){for (int y=0;x;x=fa[y=x]) splay(x),ch[x][1]=y,pushup(x);}void makeroot(int x){access(x);splay(x);pushr(x);}int findroot(int x){    access(x);splay(x);    while (ch[x][0]) pushdown(x),x=ch[x][0];    return x;}void split(int x,int y){makeroot(x);access(y);splay(y);}void link(int x,int y){makeroot(x);if (findroot(y)!=x) fa[x]=y;}void cut(int x,int y){    makeroot(x);    if (findroot(y)==x&amp;&amp;fa[x]==y&amp;&amp;!ch[x][1])        fa[x]=ch[y][0]=0,pushup(y);}int main(){    int n=read(),m=read();    for (int i=1;i&lt;=n;i++) key[i]=read();    while (m--)    {        int q=read(),x=read(),y=read();        if (q==0) {split(x,y);printf(&quot;%d\n&quot;,sum[y]);}        if (q==1) link(x,y);        if (q==2) cut(x,y);        if (q==3) splay(x),key[x]=y;    }    return 0;}</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;关于-LCT-Link-Cut-Tree&quot;&gt;&lt;a href=&quot;#关于-LCT-Link-Cut-Tree&quot; class=&quot;headerlink&quot; title=&quot;关于 LCT(Link-Cut-Tree)&quot;&gt;&lt;/a&gt;关于 LCT(Link-Cut-Tree)&lt;/h1&gt;&lt;p&gt;说难不难，总归是个板子；说简单也不简单，写法千变万化。总的来说就是把板子背熟，才能在考场上写的出来（但是貌似写的出来也看不出来 (～￣▽￣)～  ）&lt;/p&gt;
    
    </summary>
    
      <category term="LCT" scheme="http://yoursite.com/categories/LCT/"/>
    
    
      <category term="蒟蒻的LCT" scheme="http://yoursite.com/tags/%E8%92%9F%E8%92%BB%E7%9A%84LCT/"/>
    
  </entry>
  
</feed>
