<!DOCTYPE html>
<html>
  <!-- Html Head Tag-->
  <head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="">
  <meta name="author" content="high-cold">
  <!-- Open Graph Data -->
  <meta property="og:title" content="左偏树（可并堆）"/>
  <meta property="og:description" content="" />
  <meta property="og:site_name" content="High-Cold"/>
  <meta property="og:type" content="article" />
  <meta property="og:image" content="http://yoursite.com"/>
  
    <link rel="alternate" href="/atom.xml" title="High-Cold" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  <!-- Site Title -->
  <title>High-Cold</title>

  <!-- Bootstrap CSS -->
  <link rel="stylesheet" href="/css/bootstrap.min.css">
  <!-- Custom CSS -->
  
  <link rel="stylesheet" href="/css/style.light.css">

  <!-- Google Analytics -->
  

</head>


<script src="//cdn.bootcss.com/pace/1.0.2/pace.min.js"></script>
<link href="//cdn.bootcss.com/pace/1.0.2/themes/pink/pace-theme-flash.css" rel="stylesheet">

<style>
    .pace .pace-progress {
    	background: #1E92FB; /*进度条颜色*/
    	height: 3px;
    }
    .pace .pace-progress-inner {
     	box-shadow: 0 0 10px #1E92FB, 0 0 5px #1E92FB; /*阴影颜色*/
    }
    .pace .pace-activity {
    	border-top-color: #1E92FB;	/*上边框颜色*/
    	border-left-color: #1E92FB;	/*左边框颜色*/
    }
  </style>
  <body>
    <!-- Page Header -->


<header class="site-header header-background" style="background-image: url(/img/default-banner-light.jpg)">
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="page-title with-background-image">
          <p class="title">左偏树（可并堆）</p>
          <p class="subtitle"></p>
        </div>
        <div class="site-menu with-background-image">
          <ul>
            
              <li>
                <a href="/">
                  
                  Home
                  
                </a>
              </li>
            
              <li>
                <a href="/archives">
                  
                  Archives
                  
                </a>
              </li>
            
              <li>
                <a href="https://github.com/high-cold">
                  
                  Github
                  
                </a>
              </li>
            
              <li>
                <a href="http://1286791085@qq.com">
                  
                  Email
                  
                </a>
              </li>
            
          </ul>
        </div>
      </div>
    </div>
  </div>
</header>

<article>
  <div class="container typo">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <div class="post-info text-muted">
          
            <!-- Author -->
            <span class="author info">By high-cold</span>
          
          <!-- Date -->
          <span class="date-time info">On
            <span class="date">05/14/18</span>
            <span class="time">09:20:17</span>
          </span>
          
          <!--  Categories  -->
            <span class="categories info">Under 

<a href="/categories/左偏树/">左偏树</a>
</span>
          
        </div>
        <!-- Tags -->
        
          <div class="post-tags text-muted">
            Tags: 

<a class="tag" href="/tags/蒟蒻的板子/">#蒟蒻的板子</a>


          </div>
        
        <!-- Post Main Content -->
        <div class="post-content">
          <h1 id="左偏树-Leftist-Tree-是一种可并堆的实现。"><a href="#左偏树-Leftist-Tree-是一种可并堆的实现。" class="headerlink" title="左偏树(Leftist Tree)是一种可并堆的实现。"></a>左偏树(Leftist Tree)是一种可并堆的实现。</h1><p>左偏树相比于有两个额外的属性：键值和距离。<br><strong> 键值 </strong>是用于比较节点的大小。<br><strong> 距离 </strong>则是如下定义的：<br>节点i称为外节点(external node)，当且仅当节点i的左子树或右子树为空(left(i)=NULL或right(i)=NULL)。<br>节点i的距离(dist(i))是节点i到它的后代中，最近的外节点所经过的边数。<br>特别的，如果节点i本身是外节点，则它的距离为0；而空节点的距离规定为-1 (dist(NULL)=-1)。</p>
<a id="more"></a>
<p>左偏树满足下面两条基本性质：</p>
<p>[性质1] 节点的键值小于或等于它的左右子节点的键值。即key(i)≤key(parent(i))</p>
<h5 id="性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i"><a href="#性质2-节点的左子节点的距离不小于右子节点的距离。即dist-left-i-≥dist-right-i" class="headerlink" title="[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))"></a>[性质2] 节点的左子节点的距离不小于右子节点的距离。即dist(left(i))≥dist(right(i))</h5><p>这两条性质是对每一个节点而言的，因此可以简单地从中得出，左偏树的左右子树都是左偏树。<br>由这两条性质，我们可以得出左偏树的定义：左偏树是具有左偏性质的堆有序二叉树。</p>
<p>下图是一棵左偏树：<br><img src="https://s1.ax1x.com/2018/05/16/CyMnNF.png" alt=""></p>
<p>[性质3] 节点的距离等于它的右子节点的距离加1。即dist(i)=dist(right(i))+1。</p>
<p>左偏树并不是为了快速访问所有的节点而设计的，它的目的是快速访问最小节点以及在对树修改后快速的恢复堆性质。<br>从图中我们可以看到它并不平衡，由于性质2的缘故，它的结构偏向左侧，不过距离的概念和树的深度并不同，左偏树并不意味着<strong> 左子树的节点数或是深度一定大于右子树。 </strong></p>
<p>下面我们来讨论左偏树的距离和节点数的关系。</p>
<p><strong> [引理1] </strong> 若左偏树的距离为一定值，则节点数最少的左偏树是完全二叉树。<br>证明：由性质2可知，当且仅当对于一棵左偏树中的每个节点i，都有dist(left(i))=dist(right(i))时，该左偏树的节点数最少。显然具有这样性质的二叉树是完全二叉树。</p>
<p><strong> [定理1] </strong> 若一棵左偏树的距离为k，则这棵左偏树至少有2^(k+1)-1个节点。<br>证明：由引理1可知，当这样的左偏树节点数最少的时候，是一棵完全二叉树。距离为k的完全二叉树高度也为k，节点数为2^(k+1)-1，所以距离为k的左偏树至少有2k＋1-1个节点。</p>
<p>作为定理1的推论，我们有：</p>
<p>[性质4] 一棵N个节点的左偏树距离最多为O(log(N+1)-1)。</p>
<p>有了上面的4个性质，我们可以开始讨论左偏树的操作了。</p>
<h2 id="左偏树的合并"><a href="#左偏树的合并" class="headerlink" title="左偏树的合并"></a>左偏树的合并</h2><p>C ← Merge(A,B)<br>把A,B两棵左偏树合并，返回一棵新的左偏树C，包含A和B中的所有元素。在本文中，一棵左偏树用它的根节点的指针表示。</p>
<p>在合并操作中，最简单的情况是其中一棵树为空（也就是，该树根节点指针为NULL）。这时我们只须要返回另一棵树。</p>
<p>若A和B都非空，我们假设A的根节点小于等于B的根节点（否则交换A,B），把A的根节点作为新树C的根节点，剩下的事就是合并A的右子树right(A)和B了。</p>
<p>right(A) ← Merge(right(A),B)</p>
<p>为了维护左偏性质，若dist(left(A))&gt;dist(right(A))，交换left(A)和right(A)。</p>
<p>最后，由于right(A) 的距离可能发生改变，我们必须更新A的距离：<br>dist(A) ← dist(right(A)) + 1</p>
<p>于是合并就完成了。</p>
<p>下图是一个合并过程的示例：</p>
<p><img src="https://s1.ax1x.com/2018/05/16/CyMQ39.png" alt=""></p>
<h2 id="插入新节点"><a href="#插入新节点" class="headerlink" title="插入新节点"></a>插入新节点</h2><p>单节点的树一定是左偏树，因此向左偏树插入一个节点可以看作是对两棵左偏树的合并。</p>
<p>由于合并的其中一棵树只有一个节点，因此插入新节点操作的时间复杂度是O(logn)。</p>
<h2 id="删除最小节点"><a href="#删除最小节点" class="headerlink" title="删除最小节点"></a>删除最小节点</h2><p>由性质1，我们知道，左偏树的根节点是最小节点。在删除根节点后，剩下的两棵子树都是左偏树，需要把他们合并。</p>
<p>由于删除最小节点后只需进行一次合并，因此删除最小节点的时间复杂度也为O(logn)。</p>
<h2 id="左偏树的构建"><a href="#左偏树的构建" class="headerlink" title="左偏树的构建"></a>左偏树的构建</h2><p>将n个节点构建成一棵左偏树，这也是一个常用的操作。</p>
<p>算法一  暴力算法——逐个节点插入，时间复杂度为O(nlogn)。</p>
<p>算法二  仿照二叉堆的构建算法，我们可以得到下面这种算法：<br>    将n个节点（每个节点作为一棵左偏树）放入先进先出队列。不断地从队首取出两棵左偏树，将它们合并之后加入队尾。当队列中只剩下一棵左偏树时，算法结束，时间复杂度为O(n)。</p>
<p><img src="https://s1.ax1x.com/2018/05/16/CyMcE8.png" alt=""></p>
<p>代码如下：</p>
<pre><code>#include &lt;algorithm&gt; //STL通用算法
#include &lt;cmath&gt; //定义数学函数
#include &lt;cstdio&gt; //定义输入/输出函数
#include &lt;iostream&gt; //数据流输入/输出
#include &lt;cstring&gt; //字符串处理
#include &lt;string&gt; //字符串类
#include &lt;ctime&gt; //定义关于时间的函数
#define itn int
#define fro for
#define ll long long
#define reg register
#define inf 1234567890
/*#include &lt;bitset&gt; //STL位集容器
#include &lt;cstype&gt; //字符处理
#include &lt;cerrno&gt; //定义错误码
#include &lt;complex&gt; //复数类
#include &lt;clocale&gt; //定义本地化函数
#include &lt;cstdlib&gt; //定义杂项函数及内存分配函数
#include &lt;deque&gt; //STL双端队列容器
#include &lt;exception&gt; //异常处理类
#include &lt;fstream&gt; //文件输入/输出
#include &lt;functional&gt; //STL定义运算函数(代替运算符)
#include &lt;limits&gt; //定义各种数据类型最值常量
#include &lt;list&gt; //STL线性列表容器
#include &lt;map&gt; //STL映射容器
#include &lt;iomanip&gt; //参数化输入/输出
#include &lt;ios&gt; //基本输入/输出支持
#include &lt;iosfwd&gt; //输入/输出系统使用的前置声明
#include &lt;istream&gt; //基本输入流
#include &lt;ostream&gt; //基本输出流
#include &lt;queue&gt; //STL队列容器
#include &lt;set&gt; //STL集合容器
#include &lt;sstream&gt; //基于字符串的流
#include &lt;stack&gt; //STL堆栈容器
#include &lt;stdexcept&gt; //标准异常类
#include &lt;streambuf&gt; //底层输入/输出支持
#include &lt;utility&gt; //STL通用模板类
#include &lt;vector&gt; //STL动态数组容器
#include &lt;cwchar.h&gt;//宽字符处理及输入/输出
#include &lt;cwctype.h&gt; //宽字符分类*/

using namespace std;

int ans;

int max(int x,int y){return x&gt;y?x:y;}

int min(int x,int y){return x&lt;y?x:y;}

void swap(int &amp;x,int &amp;y){int d=x;x=y;y=d;}

int read()
{
    int x=0,f=1;char ch=getchar();
    while (ch&lt;&apos;0&apos; || ch&gt;&apos;9&apos;){if (ch==&apos;-&apos;)f=-1;ch=getchar();}
    while (&apos;0&apos;&lt;=ch &amp;&amp; ch&lt;=&apos;9&apos;){x=x*10+(ch^48);ch=getchar();}
    return x*f;
}

void write(int x)
{
    int buf[50];
    if (x&lt;0) putchar(&apos;-&apos;),x=-x;
    buf[0]=0;
    while (x) buf[++buf[0]]=x%10,x/=10; 
    if (!buf[0]) buf[0]=1,buf[1]=0;
    while (buf[0]) putchar(&apos;0&apos;+buf[buf[0]--]);
}

int fa[100100],dist[100100],Left[100100],Right[100100],key[100100];

int find(int x)
{
    return fa[x]?find(fa[x]):x;
}

int merge(int x,int y)
{
    if (x==0) return y;
    if (y==0) return x;
    if (key[y]&lt;key[x]||(key[x]==key[y]&amp;&amp;x&gt;y)) swap(x,y);
    int &amp;l=Left[x],&amp;r=Right[x];
    r=merge(r,y);
    fa[r]=x;
    if (dist[r]&gt;dist[l]) swap(l,r);
    dist[x]=dist[r]+1;
}

void Delete(int x)
{
    key[x]=-1;
    fa[Right[x]]=fa[Left[x]]=0;
    merge(Left[x],Right[x]);
}

int main(){
    int n=read(),m=read();
    dist[0]=-1;
    for (int i=1;i&lt;=n;i++) key[i]=read();
    while (233333&amp;&amp;m--)
    {
        int q=read();
        if (q==1)
        {
            int x=read(),y=read();
            if (key[x]==-1||key[y]==-1) continue;
            x=find(x),y=find(y);
            if (x!=y) merge(x,y);
        }
        if (q==2)
        {
            int x=read();
            if (key[x]==-1) printf(&quot;-1\n&quot;);
            else 
            {
                x=find(x);
                printf(&quot;%d\n&quot;,key[x]);
                Delete(x);
            }
        }
    }
    return 0;
}
</code></pre>
        </div>
      </div>
    </div>
  </div>
</article>



    <script async src="//dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"></script>
<!-- Footer -->
<footer>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <p class="copyright text-muted">
          Theme By <a target="_blank" href="https://github.com/high-cold">High-Cold.</a>
          Inspired By <a target="_blank" href="https://github.com/klugjo/hexo-theme-clean-blog">Clean Blog.</a>
        <p class="copyright text-muted">
          Powered By <a target="_blank" href="https://hexo.io/">Hexo.</a>
        </p>
		<span id="busuanzi_container_site_pv">
		  本站总访问量 <span id="busuanzi_value_site_pv"></span> 次
		</span>
      </div>
    </div>
  </div>
</footer>


    <!-- After Footer Scripts -->
<script src="/js/highlight.pack.js"></script>
<script>
  document.addEventListener("DOMContentLoaded", function(event) {
    var codeBlocks = Array.prototype.slice.call(document.getElementsByTagName('pre'))
    codeBlocks.forEach(function(block, index) {
      hljs.highlightBlock(block);
    });
  });
</script>

  </body>
</html>

